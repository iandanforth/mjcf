from mjcf.element import Element


class Asset(Element):
    """

    This is a grouping element for defining assets. It does not have attributes.
    Assets are created in the model so that they can be referenced from other
    model elements; recall the discussion of Assets in the Overview chapter.

    """
    def __init__(
        self,
    ):
        super().__init__()
        self._attribute_names = []


class Texture(Element):
    """

    This element creates a texture asset, which is then referenced from a
    material asset, which is finally referenced from a model element that needs
    to be textured. MuJoCo provides access to the texture mapping mechanism in
    OpenGL. Texture coordinates are generated automatically in GL_OBJECT_PLANE
    mode, using either 2D or cube mapping. MIP maps are always enabled in
    GL_LINEAR_MIPMAP_LINEAR mode. The texture color is combined with the object
    color in GL_MODULATE mode. The texture data can be loaded from PNG files,
    with provisions for loading cube and skybox textures. Alternatively the data
    can be generated by the compiler as a procedural texture. Because different
    texture types require different parameters, only a subset of the attributes
    below are used for any given texture.

    """
    def __init__(
        self,
        builtin="none",
        file=None,
        fileback=None,
        filedown=None,
        filefront=None,
        fileleft=None,
        fileright=None,
        fileup=None,
        gridlayout=None,
        gridsize="1 1",
        height="0",
        mark="none",
        markrgb="0 0 0",
        name=None,
        random="0.01",
        rgb1="0.8 0.8 0.8",
        rgb2="0.5 0.5 0.5",
        type="cube",
        width="0",
    ):
        super().__init__()
        self.builtin = builtin
        self.file = file
        self.fileback = fileback
        self.filedown = filedown
        self.filefront = filefront
        self.fileleft = fileleft
        self.fileright = fileright
        self.fileup = fileup
        self.gridlayout = gridlayout
        self.gridsize = gridsize
        self.height = height
        self.mark = mark
        self.markrgb = markrgb
        self.name = name
        self.random = random
        self.rgb1 = rgb1
        self.rgb2 = rgb2
        self.type = type
        self.width = width
        self._attribute_names = ['builtin', 'file', 'fileback', 'filedown', 'filefront', 'fileleft', 'fileright', 'fileup', 'gridlayout', 'gridsize', 'height', 'mark', 'markrgb', 'name', 'random', 'rgb1', 'rgb2', 'type', 'width']


class Hfield(Element):
    """

    This element creates a height field asset, which can then be referenced from
    geoms with type "hfield". A height field, also known as terrain map, is a 2D
    matrix of elevation data. The data can be specified in one of three ways:

    """
    def __init__(
        self,
        size,
        file=None,
        name=None,
        ncol="0",
        nrow="0",
    ):
        super().__init__()
        self.size = size
        self.file = file
        self.name = name
        self.ncol = ncol
        self.nrow = nrow
        self._attribute_names = ['size', 'file', 'name', 'ncol', 'nrow']


class Mesh(Element):
    """

    This element creates a mesh asset, which can then be referenced from geoms.
    If the referencing geom type is "mesh" the mesh is instantiated in the
    model, otherwise a geometric primitive is automatically fitted to it; see
    geom element below.

    MuJoCo works with triangulated meshes loaded from binary STL files. Software
    such as MeshLab can be used to convert from other mesh formats to STL. While
    any collection of triangles can be loaded as a mesh and rendered, collision
    detection works with the convex hull of the mesh as explained in Collision
    detection in the Computation chapter. See also the convexhull attribute of
    the compiler element which controls the automatic generation of convex
    hulls. Since the STL format does not support color, the mesh appearance is
    controlled by the referencing geom, similarly to height fields. We are
    considering support for richer file formats which also specify color, but
    this functionality is not yet available.

    Poorly designed meshes can display rendering artifacts. In particular, the
    shadow mapping mechanism relies on having some distance between front and
    back-facing triangle faces. If the faces are repeated, with opposite normals
    as determined by the vertex order in each triangle, this causes shadow
    aliasing. The solution is to remove the repeated faces (which can be done in
    MeshLab) or use a better designed mesh.

    The size of the mesh is determined by the 3D coordinates of the vertex data
    in the mesh file, multiplied by the components of the scale attribute below.
    Scaling is applied separately for each coordinate axis. Note that negative
    scaling values can be used to flip the mesh; this is a legitimate operation.
    The size parameters of the referening geoms are ignored, similarly to height
    fields.

    Positioning and orienting is complicated by the fact that vertex data are
    often designed relative to coordinate frames whose origin is not inside the
    mesh. In contrast, MuJoCo expects the origin of a geom's local frame to
    coincide with the geometric center of the shape. We resolve this discrepancy
    by pre-processing the mesh in the compiler, so that it is centered around
    (0,0,0) and its principal axes of inertia are the coordinate axes. We also
    save the translation and rotation offsets needed to achieve such alignment.
    These offsets are then applied to the referencing geom's position and
    orientation; see also mesh attribute of geom below. Fortunately most meshes
    used in robot models are designed in a coordinate frame centered at the
    joint. This makes the corresponding MJCF model intuitive: we set the body
    frame at the joint, so that the joint position is (0,0,0) in the body frame,
    and simply reference the mesh. Below is an MJCF model fragment of a forearm,
    containing all the information needed to put the mesh where one would expect
    it to be. The body position is specified relative to the parent body, namely
    the upper arm (not shown). It is offset by 35 cm which is the typical length
    of the human upper arm. If the mesh vertex data were not designed in the
    above convention, we would have to use the geom position and orientation to
    compensate, but in practice this is rarely needed.

    """
    def __init__(
        self,
        file,
        class_=None,
        name=None,
        scale="1 1 1",
    ):
        super().__init__()
        self.file = file
        self.class_ = class_
        self.name = name
        self.scale = scale
        self._attribute_names = ['file', 'class_', 'name', 'scale']


class Material(Element):
    """

    This element creates a material asset. It can be referenced from geoms,
    sites and tendons to set their appearance. Note that all these elements also
    have a local rgba attribute, which is more convenient when only colors need
    to be adjusted, because it does not require creating materials and
    referencing them. Materials are useful for adjusting appearance properties
    beyond color. However once a material is created, it is more natural the
    specify the color using the material, so that all appearance properties are
    grouped together.

    """
    def __init__(
        self,
        name,
        class_=None,
        emission="0",
        reflectance="0",
        rgba="1 1 1 1",
        shininess="0.5",
        specular="0.5",
        texrepeat="1 1",
        texture=None,
        texuniform="false",
    ):
        super().__init__()
        self.name = name
        self.class_ = class_
        self.emission = emission
        self.reflectance = reflectance
        self.rgba = rgba
        self.shininess = shininess
        self.specular = specular
        self.texrepeat = texrepeat
        self.texture = texture
        self.texuniform = texuniform
        self._attribute_names = ['name', 'class_', 'emission', 'reflectance', 'rgba', 'shininess', 'specular', 'texrepeat', 'texture', 'texuniform']
