
<!-- saved from url=(0036)http://mujoco.org/book/modeling.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
    <title>MuJoCo Modeling</title>
    <link href="./modeling_files/style.css" rel="stylesheet" type="text/css">
    <link rel="icon" type="image/png" href="http://mujoco.org/book/icon.png"> 
    <link href="./modeling_files/prettify.css" type="text/css" rel="stylesheet">
    <script type="text/javascript" src="./modeling_files/prettify.js"></script>
</head>

<body onload="prettyPrint()" cz-shortcut-listen="true">

<table>
<tbody><tr>
<td>

<div id="menu">
    <div class="ch"><a class="menuback" href="http://www.mujoco.org/index.html">&#8592;&nbsp;mujoco.org</a></div>
    <div class="ch"><a class="menu" href="http://mujoco.org/book/index.html">Overview</a></div>
    <div class="ch"><a class="menu" href="http://mujoco.org/book/computation.html">Computation</a></div>
    <div class="chsel"><a class="menusel" href="http://mujoco.org/book/modeling.html">Modeling</a></div>
    <div class="ch"><a class="menu" href="http://mujoco.org/book/programming.html">Programming</a></div>
    <div class="ch"><a class="menu" href="http://mujoco.org/book/reference.html">Reference</a></div>
    <div class="ch"><a class="menu" href="http://mujoco.org/book/haptix.html">HAPTIX</a></div>
    <div class="ch"><a class="menu" href="http://mujoco.org/book/unity.html">Unity Plugin</a></div>
</div>


<div id="contents">

<a class="contents" style="font-size:16" href="http://mujoco.org/book/modeling.html#Introduction">Introduction</a>
<div style="padding-left:10">
    <a class="contents" href="http://mujoco.org/book/modeling.html#Load">Loading</a>
    <a class="contents" href="http://mujoco.org/book/modeling.html#Compile">Compiling</a>
    <a class="contents" href="http://mujoco.org/book/modeling.html#Save">Saving</a>
</div>
<br>

<a class="contents" style="font-size:16" href="http://mujoco.org/book/modeling.html#Mechanisms">Mechanisms</a>
<div style="padding-left:10">
    <a class="contents" href="http://mujoco.org/book/modeling.html#CTree">Kinematic tree</a>
    <a class="contents" href="http://mujoco.org/book/modeling.html#CDefault">Default settings</a>
    <a class="contents" href="http://mujoco.org/book/modeling.html#CFrame">Coordinate frames</a>
    <a class="contents" href="http://mujoco.org/book/modeling.html#COrientation">Frame orientations</a>
    <a class="contents" href="http://mujoco.org/book/modeling.html#CSolver">Solver parameters</a>
    <a class="contents" href="http://mujoco.org/book/modeling.html#CAlgorithms">Algorithms</a>
    <a class="contents" href="http://mujoco.org/book/modeling.html#COverride">Contact override</a>
    <a class="contents" href="http://mujoco.org/book/modeling.html#CUser">User parameters</a>
    <a class="contents" href="http://mujoco.org/book/modeling.html#CActuator">Actuator shortcuts</a>
    <a class="contents" href="http://mujoco.org/book/modeling.html#CLengthRange">Length range</a>
    <a class="contents" href="http://mujoco.org/book/modeling.html#CMuscle">Muscles</a>
    <a class="contents" href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>
    <a class="contents" href="http://mujoco.org/book/modeling.html#CInclude">Including files</a>
    <a class="contents" href="http://mujoco.org/book/modeling.html#CName">Naming elements</a>
    <a class="contents" href="http://mujoco.org/book/modeling.html#CURDF">URDF extensions</a>
</div>
<br>

<a class="contents" style="font-size:16" href="http://mujoco.org/book/modeling.html#Summary">MJCF summary</a>
<div style="padding-left:10">
    <a class="contents" href="http://mujoco.org/book/modeling.html#CSchema">XML schema</a>
    <a class="contents" href="http://mujoco.org/book/modeling.html#CType">Attribute types</a>
    <a class="contents" href="http://mujoco.org/book/modeling.html#CKeyword">Keyword lists</a>
</div>
<br>

<a class="contents" style="font-size:16" href="http://mujoco.org/book/modeling.html#Reference">MJCF reference</a>
<div style="padding-left:10">
    <a class="contents" href="http://mujoco.org/book/modeling.html#include">include</a>
    <a class="contents" href="http://mujoco.org/book/modeling.html#mujoco">mujoco</a>
    <div style="padding-left:10">
        <a class="contents" href="http://mujoco.org/book/modeling.html#compiler">compiler</a>
        <div style="padding-left:15">
            <a class="contents" href="http://mujoco.org/book/modeling.html#compiler-lengthrange">lengthrange</a>
        </div>
        <a class="contents" href="http://mujoco.org/book/modeling.html#option">option</a>
        <div style="padding-left:15">
            <a class="contents" href="http://mujoco.org/book/modeling.html#option-flag">flag</a>
        </div>
        <a class="contents" href="http://mujoco.org/book/modeling.html#size">size</a>
        <a class="contents" href="http://mujoco.org/book/modeling.html#visual">visual</a>
        <div style="padding-left:20">
            <a class="contents" href="http://mujoco.org/book/modeling.html#global">global</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#quality">quality</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#headlight">headlight</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#map">map</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#scale">scale</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#rgba">rgba</a>
        </div>
        <a class="contents" href="http://mujoco.org/book/modeling.html#statistic">statistic</a>
        <a class="contents" href="http://mujoco.org/book/modeling.html#default">default</a>
        <div style="padding-left:15">
            <a class="contents" href="http://mujoco.org/book/modeling.html#default-mesh">mesh</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#default-material">material</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#default-joint">joint</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#default-geom">geom</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#default-site">site</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#default-camera">camera</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#default-light">light</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#default-pair">pair</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#default-equality">equality</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#default-tendon">tendon</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#default-general">general</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#default-motor">motor</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#default-position">position</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#default-velocity">velocity</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#default-cylinder">cylinder</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#default-muscle">muscle</a>
        </div>
        <a class="contents" href="http://mujoco.org/book/modeling.html#custom">custom</a>
        <div style="padding-left:15">
            <a class="contents" href="http://mujoco.org/book/modeling.html#numeric">numeric</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#text">text</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#tuple">tuple</a>
            <div style="padding-left:20">
                <a class="contents" href="http://mujoco.org/book/modeling.html#tupleelement">element</a>
            </div>
        </div>
        <a class="contents" href="http://mujoco.org/book/modeling.html#asset">asset</a>
        <div style="padding-left:15">
            <a class="contents" href="http://mujoco.org/book/modeling.html#texture">texture</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#hfield">hfield</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#mesh">mesh</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#material">material</a>
        </div>

        <a class="contents" href="http://mujoco.org/book/modeling.html#body">(world) body</a>
        <div style="padding-left:20">
            <a class="contents" href="http://mujoco.org/book/modeling.html#inertial">inertial</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#joint">joint</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#freejoint">freejoint</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#geom">geom</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#site">site</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#camera">camera</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#light">light</a>
        </div>
        <a class="contents" href="http://mujoco.org/book/modeling.html#contact">contact</a>
        <div style="padding-left:15">
            <a class="contents" href="http://mujoco.org/book/modeling.html#pair">pair</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#exclude">exclude</a>
        </div>
        <a class="contents" href="http://mujoco.org/book/modeling.html#equality">equality</a>
        <div style="padding-left:15">
            <a class="contents" href="http://mujoco.org/book/modeling.html#equality-connect">connect</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#equality-weld">weld</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#equality-joint">joint</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#equality-tendon">tendon</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#equality-distance">distance</a>
        </div>
        <a class="contents" href="http://mujoco.org/book/modeling.html#tendon">tendon</a>
        <div style="padding-left:15">
            <a class="contents" href="http://mujoco.org/book/modeling.html#spatial">spatial</a>
            <div style="padding-left:20">
                <a class="contents" href="http://mujoco.org/book/modeling.html#spatial-site">site</a>
                <a class="contents" href="http://mujoco.org/book/modeling.html#spatial-geom">geom</a>
                <a class="contents" href="http://mujoco.org/book/modeling.html#spatial-pulley">pulley</a>
            </div>  
            <a class="contents" href="http://mujoco.org/book/modeling.html#fixed">fixed</a>
            <div style="padding-left:20">
                <a class="contents" href="http://mujoco.org/book/modeling.html#fixed-joint">joint</a>
            </div>
        </div>
        <a class="contents" href="http://mujoco.org/book/modeling.html#actuator">actuator</a>
        <div style="padding-left:15">
            <a class="contents" href="http://mujoco.org/book/modeling.html#general">general</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#motor">motor</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#position">position</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#velocity">velocity</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#cylinder">cylinder</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#muscle">muscle</a>
        </div>  
        <a class="contents" href="http://mujoco.org/book/modeling.html#sensor">sensor</a>
        <div style="padding-left:15">
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-touch">touch</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-accelerometer">accelerometer</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-velocimeter">velocimeter</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-gyro">gyro</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-force">force</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-torque">torque</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-magnetometer">magnetometer</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-rangefinder">rangefinder</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-jointpos">jointpos</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-jointvel">jointvel</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-tendonpos">tendonpos</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-tendonvel">tendonvel</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-actuatorpos">actuatorpos</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-actuatorvel">actuatorvel</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-actuatorfrc">actuatorfrc</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-ballquat">ballquat</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-ballangvel">ballangvel</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-framepos">framepos</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-framequat">framequat</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-framexaxis">framexaxis</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-frameyaxis">frameyaxis</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-framezaxis">framezaxis</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-framelinvel">framelinvel</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-frameangvel">frameangvel</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-framelinacc">framelinacc</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-frameangacc">frameangacc</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-subtreecom">subtreecom</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-subtreelinvel">subtreelinvel</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-subtreeangmom">subtreeangmom</a>
            <a class="contents" href="http://mujoco.org/book/modeling.html#sensor-user">user</a>
        </div>  
        <a class="contents" href="http://mujoco.org/book/modeling.html#keyframe">keyframe</a>
        <div style="padding-left:15">
            <a class="contents" href="http://mujoco.org/book/modeling.html#key">key</a>
        </div>
    </div>
    <br>
</div>
</div>
</td>


<td class="chapter">

<h1 id="Introduction">Chapter 3: &nbsp;Modeling</h1>

<h2>Introduction</h2>
<p>
    MuJoCo can load XML model files in its native <b>MJCF</b> format, as well as in the popular but more limited <b>URDF</b> format. This chapter documents the MJCF format. The URDF documentation can be found elsewhere; here we only describe MuJoCo-specific <a href="http://mujoco.org/book/modeling.html#CURDF">URDF extensions</a>.
    <br><br>

    MJCF models can represent complex dynamical systems with a wide range of features and model elements. Accessing all these features requires a rich modeling format, which can become cumbersome if it is not designed with usability in mind. Therefore we have made an effort to design MJCF as a scalable format, allowing users to start small and build more detailed models later. Particularly helpful in this regard is the extensive <a href="http://mujoco.org/book/modeling.html#CDefault">default setting</a> mechanism inspired by the idea of Cascading Style Sheets (CSS) in HTML. It enables users to rapidly create new models and experiment with them. Experimentation is further aided by numerous <a href="http://mujoco.org/book/modeling.html#option">options</a> which can be used to reconfigure the simulation pipeline, and by quick re-loading that makes model editing an interactive process.
    <br><br>

    One can think of MJCF as a hybrid between a modeling format and a programming language. There is a built-in compiler, which is a concept normally associated with programming languages. While MJCF does not have the power of a general-purpose programming language, a number of sophisticated compile-time computations are invoked automatically depending on how the model is designed. This explains why the present chapter is longer and more complex than one might have expected: our agenda here lies between documenting a modeling format, and teaching users how to program in a new language.
</p>


<h4 id="Load">Loading models</h4>
<p>
    As explained in <a href="http://mujoco.org/book/index.html#Instance">Model instances</a> in the Overview chapter, MuJoCo models can be loaded from plain-text XML files in the MJCF or URDF formats, and then compiled into a low-level mjModel. Alternatively a previously saved mjModel can be loaded directly from a binary MJB file - whose format is not documented but is essentially a copy of the mjModel memory buffer. MJCF and URDF files are loaded with <a href="http://mujoco.org/book/reference.html#mj_loadXML">mj_loadXML</a> while MJB files are loaded with <a href="http://mujoco.org/book/reference.html#mj_loadModel">mj_loadModel</a>.
    <br><br>

    When an XML file is loaded, it is first parsed into a document object model (DOM) using the TinyXML parser internally. This DOM is then processed and converted into a high-level mjCModel object. The conversion depends on the model format - which is inferred from the top-level element in the XML file, and not from the file extension. Recall that a valid XML file has a unique top-level element. This element must be <span class="el">mujoco</span> for MJCF, and <span class="el">robot</span> for URDF.
</p>


<h4 id="Compile">Compiling models</h4>
<p> 
    Once a high-level mjCModel is created - by loading an MJCF file or an URDF file, or programmatically when such functionality becomes available - it is compiled into mjModel. Even though loading and compilation are presently combined in one step, compilation is independent of loading, meaning that the compiler works in the same way regardless of how mjCModel was created. Both the parser and the compiler perform extensive error checking, and abort when the first error is encountered. The resulting error messages contain the row and column number in the XML file, and are self-explanatory so we do not document them here. The parser uses a custom schema to make sure that the file structure, elements and attributes are valid. The compiler then applies many additional semantic checks. Finally, one simulation step of the compiled model is performed and any runtime errors are intercepted. The latter is done by (temporarily) setting <a href="http://mujoco.org/book/reference.html#mju_user_error">mju_user_error</a> to point to a function that throws C++ exceptions; the user can implement similar error-interception functionality at runtime if desired.
    <br><br>

    The entire process of parsing and compilation is very fast - less than a second if the model does not contain large meshes that require processing. This makes it possible to design models interactively, by re-loading often and visualizing the changes. Note that both HAPTIX and the simulate.cpp code sample in Pro have a keyboard shortcut for re-loading the current model (Ctrl+L).
</p>


<h4 id="Save">Saving models</h4>
<p> 
    An MJCF model can consist of multiple (included) XML files as well as meshes, height fields and textures referenced from the XML. After compilation, the contents of all these files are assembled into mjModel, which can be saved into a binary MJB file with <a href="http://mujoco.org/book/reference.html#mj_saveModel">mj_saveModel</a>. The MJB is a stand-alone file and does not refer to any other files. It also loads faster, especially when the XML contains meshes that require processing by the compiler. So we recommend saving commonly used models as MJB and loading them when needed for simulation.
    <br><br>

    It is also possible to save a compiled mjCModel as MJCF with <a href="http://mujoco.org/book/reference.html#mj_saveLastXML">mj_saveLastXML</a>. If any real-valued fields in the corresponding mjModel were modified after compilation (which is unusual but can happen in system identification applications for example), the modifications are automatically copied back into mjCModel before saving. Note that structural changes cannot be made in the compiled model. The XML writer attempts to generate the smallest MJCF file which is guaranteed to compile into the same model, modulo negligible numeric differences caused by the plain text representation of real values. The resulting file may not have the same structure as the original because MJCF has many user convenience features, allowing the same model to be specified in different ways. The XML writer uses a "canonical" subset of MJCF where all coordinates are local and all body positions, orientations and inertial properties are explicitly specified.
    In the Computation chapter we showed an <a href="http://mujoco.org/book/file/example.xml">example</a> MJCF file and the corresponding <a href="http://mujoco.org/book/file/example_saved.xml">saved example</a>.
</p>    
    

<h2 id="Mechanisms">MJCF Mechanisms</h2>
<p>
    MJCF uses several mechanisms for model creation which span multiple model elements. To avoid repetition we describe them in detail only once in this section. These mechanisms do not correspond to new simulation concepts beyond those introduced in the Computation chapter. Their role is to simplify the creation of MJFC models, and to enable the use of different data formats without need for manual conversion to a canonical format.
</p>
    

<h4 id="CTree">Kinematic tree</h4>
<p>
    The main part of the MJCF file is an XML tree created by nested <a href="http://mujoco.org/book/modeling.html#body">body</a> elements. The top-level body is special and is called <span class="el">worldbody</span>. This tree organization is in contrast with URDF where one creates a collection of links and then connects them with joints that specify a child and a parent link. In MJCF the child body is literally a child of the parent body, in the sense of XML.
    <br><br>

    When a <a href="http://mujoco.org/book/modeling.html#joint">joint</a> is defined inside a body, its function is not to connect the parent and child but rather to create motion degrees of freedom between them. If no joints are defined within a given body, that body is welded to its parent. A body in MJCF can contain multiple joints, thus there is no need to introduce dummy bodies for creating composite joints. Instead simply define all the primitive joints that form the desired composite joint within the same body. For example, two sliders and one hinge can be used to model a body moving in a plane.
    <br><br>

    Other MJCF elements can be defined within the tree created by nested body elements, in particular <a href="http://mujoco.org/book/modeling.html#joint">joint</a>, <a href="http://mujoco.org/book/modeling.html#geom">geom</a>, <a href="http://mujoco.org/book/modeling.html#site">site</a>, <a href="http://mujoco.org/book/modeling.html#camera">camera</a>, <a href="http://mujoco.org/book/modeling.html#light">light</a>. When an element is defined within a body, it is fixed to the local frame of that body and always moves with it. Elements that refer to multiple bodies, or do not refer to bodies at all, are defined in separate sections outside the kinematic tree.
</p>

    
<h4 id="CDefault">Default settings</h4>
<p> 
    MJCF has an elaborate mechanism for setting default attribute values. This allows us to have a large number of elements and attributes needed to expose the rich functionality of the software, and at the same time write short and readable model files. This mechanism further enables the user to introduce a change in one place and have it propagate throughout the model. We start with an example.
</p>

<pre class="prettyprint prettyprinted" style=""><span class="tag">&lt;mujoco&gt;</span><span class="pln">
    </span><span class="tag">&lt;default</span><span class="pln"> </span><span class="atn">class</span><span class="pun">=</span><span class="atv">"main"</span><span class="tag">&gt;</span><span class="pln">
        </span><span class="tag">&lt;geom</span><span class="pln"> </span><span class="atn">rgba</span><span class="pun">=</span><span class="atv">"1 0 0 1"</span><span class="tag">/&gt;</span><span class="pln">
        </span><span class="tag">&lt;default</span><span class="pln"> </span><span class="atn">class</span><span class="pun">=</span><span class="atv">"sub"</span><span class="tag">&gt;</span><span class="pln">
            </span><span class="tag">&lt;geom</span><span class="pln"> </span><span class="atn">rgba</span><span class="pun">=</span><span class="atv">"0 1 0 1"</span><span class="tag">/&gt;</span><span class="pln">
        </span><span class="tag">&lt;/default&gt;</span><span class="pln">
    </span><span class="tag">&lt;/default&gt;</span><span class="pln">

    </span><span class="tag">&lt;worldbody&gt;</span><span class="pln">
        </span><span class="tag">&lt;geom</span><span class="pln"> </span><span class="atn">type</span><span class="pun">=</span><span class="atv">"box"</span><span class="tag">/&gt;</span><span class="pln">
        </span><span class="tag">&lt;body</span><span class="pln"> </span><span class="atn">childclass</span><span class="pun">=</span><span class="atv">"sub"</span><span class="tag">&gt;</span><span class="pln">
            </span><span class="tag">&lt;geom</span><span class="pln"> </span><span class="atn">type</span><span class="pun">=</span><span class="atv">"ellipsoid"</span><span class="tag">/&gt;</span><span class="pln">
            </span><span class="tag">&lt;geom</span><span class="pln"> </span><span class="atn">type</span><span class="pun">=</span><span class="atv">"sphere"</span><span class="pln"> </span><span class="atn">rgba</span><span class="pun">=</span><span class="atv">"0 0 1 0"</span><span class="tag">/&gt;</span><span class="pln">
            </span><span class="tag">&lt;geom</span><span class="pln"> </span><span class="atn">type</span><span class="pun">=</span><span class="atv">"cylinder"</span><span class="pln"> </span><span class="atn">class</span><span class="pun">=</span><span class="atv">"main"</span><span class="tag">/&gt;</span><span class="pln">
        </span><span class="tag">&lt;/geom&gt;</span><span class="pln">
    </span><span class="tag">&lt;/worldbody&gt;</span><span class="pln">
</span><span class="tag">&lt;/mujoco&gt;</span></pre>

<p>
    This example will not actually compile because some required information is missing, but here we are only interested in the setting of geom rgba values. The four geoms created above will end up with the following rgba values as a result of the default setting mechanism:
    <br><br>

    <table border="1">
    <tbody><tr> <td class="el1">geom type</td> <td class="el1">geom rgba</td> </tr><tr>
    </tr><tr> <td>box</td>       <td>1 0 0 1</td> </tr>
    <tr> <td>ellipsoid</td> <td>0 1 0 1</td> </tr>
    <tr> <td>sphere</td>    <td>0 0 1 1</td> </tr>
    <tr> <td>cylinder</td>  <td>1 0 0 1</td> </tr>
    </tbody></table>
    <br>

    The box uses the top-level defaults class "main" to set the values of its undefined attributes, because no other class was specified. The body specifies childclass "sub", causing all children of this body (and all their children etc) to use class "sub" unless specified otherwise. So the ellipsoid uses class "sub". The sphere has explicitly defined rgba which overrides the default settings. The cylinder specifies defaults class "main", and so it uses "main" instead of "sub", even though the latter was specified in the childclass attribute of the body containing the geom.
    <br><br>

    Now we describe the general rules. MuJoCo supports unlimited number of defaults classes, created by possibly nested <a href="http://mujoco.org/book/modeling.html#default">default</a> elements in the XML. Each class has a unique name - which is a required attribute except for the top-level class whose name is "main" if left undefined. Each class also has a complete collection of dummy model elements, with their attributes set as follows. When a defaults class is defined within another defaults class, the child automatically inherits all attribute values from the parent. It can then override some or all of them by defining the corresponding attributes. The top-level defaults class does not have a parent, and so its attributes are initialized to internal defaults which are shown in the reference documentation below.
    <br><br>

    The dummy elements contained in the defaults classes are not part of the model; they are only used to initialize the attribute values of the actual model elements. When an actual element if first created, all its attributes are copied from the corresponding dummy element in the defaults class that is currently active. There is always an active defaults class, which can be determined in one of three ways. If no class is specified in the present element or any of its ancestor bodies, the top-level class is used (regardless of whether it is called "main" or something else). If no class is specified in the present element but one or more of its ancestor bodies specify a childclass, then the childclass from the nearest ancestor body is used. If the present element specifies a class, that class is used regardless of any childclass attributes in its ancestor bodies.
    <br><br>

    Some attributes, such as body position in models defined in global coordinates, can be in a special undefined state. This instructs the compiler to infer the corresponding value from other information, in this case the positions of the geoms attached to the body. The undefined state cannot be entered in the XML file. Therefore once an attribute is defined in a given class, it cannot be undefined in that class or in any of its child classes. So if the goal is to leave a certain attribute undefined in a given model element, in must be undefined in the active defaults class.
    <br><br>

    A final twist here are actuators. They are different because some of the actuator-related elements are actually shortcuts, and shortcuts interact with the defaults setting mechanism in a non-obvious way. This is explained in the <a href="http://mujoco.org/book/modeling.html#CActuator">Actuator shortcuts</a> section below.   
</p>
    

<h4 id="CFrame">Coordinate frames</h4>
<p>
    After compilation the positions and orientations of all elements defined in the kinematic tree are expressed in local coordinates, relative to the parent body for bodies, and relative to the body that owns the element for geoms, joints, sites, cameras and lights. Consequently, when a compiled model is saved as MJCF, the coordinates are always local. However when the user writes an MJCF file, the coordinates can be either local or global, as specified by the <span>coordinate</span> attribute of <a href="http://mujoco.org/book/modeling.html#compiler">compiler</a>. This setting applies to all position and orientation data in the MJCF file. A related attribute is <span>angle</span>. It specifies whether all angles in the MJCF file are expressed in degrees or radians (after compilation angles are always expressed in radians). Awareness of these global settings is essential when constructing new models.
    <br><br>

    Global coordinates can sometimes be more intuitive and have the added benefit that body positions and orientations can be omitted. In that case the body frame is set to the body inertial frame, which can itself be omitted and inferred from the geom masses and inertias. When an MJCF model is defined in local coordinates on the other hand, the user must specify the positions and orientations of the body frames explicitly. This is because if they were omitted, and the elements inside the body were specified in local coordinates relative to the body frame, there would be no way to infer the body frame.
    <br><br>

    Here is an example of an MJCF fragment in global coordinates:
</p>

<pre class="prettyprint prettyprinted" style=""><span class="tag">&lt;body&gt;</span><span class="pln">
   </span><span class="tag">&lt;geom</span><span class="pln"> </span><span class="atn">type</span><span class="pun">=</span><span class="atv">"box"</span><span class="pln"> </span><span class="atn">pos</span><span class="pun">=</span><span class="atv">"1 0 0"</span><span class="pln"> </span><span class="atn">size</span><span class="pun">=</span><span class="atv">"0.5 0.5 0.5"</span><span class="tag">/&gt;</span><span class="pln">
</span><span class="tag">&lt;/body&gt;</span></pre>

<p>
    When this model is compiled and saved as MJCF (in local coordinates) the same fragment becomes:
</p>    

<pre class="prettyprint prettyprinted" style=""><span class="tag">&lt;body</span><span class="pln"> </span><span class="atn">pos</span><span class="pun">=</span><span class="atv">"1 0 0"</span><span class="tag">&gt;</span><span class="pln">
   </span><span class="tag">&lt;inertial</span><span class="pln"> </span><span class="atn">pos</span><span class="pun">=</span><span class="atv">"0 0 0"</span><span class="pln"> </span><span class="atn">mass</span><span class="pun">=</span><span class="atv">"1000"</span><span class="pln"> </span><span class="atn">diaginertia</span><span class="pun">=</span><span class="atv">"166.667 166.667 166.667"</span><span class="tag">/&gt;</span><span class="pln">
   </span><span class="tag">&lt;geom</span><span class="pln"> </span><span class="atn">type</span><span class="pun">=</span><span class="atv">"box"</span><span class="pln"> </span><span class="atn">pos</span><span class="pun">=</span><span class="atv">"0 0 0"</span><span class="pln"> </span><span class="atn">size</span><span class="pun">=</span><span class="atv">"0.5 0.5 0.5"</span><span class="tag">/&gt;</span><span class="pln">
</span><span class="tag">&lt;/body&gt;</span></pre>

<p>
    The body position was set to the geom position (1 0 0), while the geom and inertial positions were set to (0 0 0) relative to the body.
    <br><br>

    In principle the user always has a choice between local and global coordinates, but in practice this choice if viable only when using geometric primitives rather than meshes. For meshes, the 3D vertex positions are expressed in either local and global coordinates depending on how the mesh was designed - effectively forcing the user to adopt the same convention for the entire model. The alternative would be to pre-process the mesh data outside MuJoCo so as to change coordinates, but that effort is rarely justified. 
</p>


<h4 id="COrientation">Frame orientations</h4>
<p> 
    Several model elements have right-handed spatial frames associated with them. These are all the elements defined in the kinematic tree except for joints. A spatial frame is defined by its position and orientation. Specifying 3D positions is straightforward, but specifying 3D orientations can be challenging. This is why MJCF provides several alternative mechanisms. No matter which mechanism the user chooses, the frame orientation is always represented as a unit quaternion after compilation. Recall that a 3D rotation by angle <i>a</i> around axis given by the unit vector (<i>x, y, z</i>) corresponds to the quaternion (cos(<i>a</i>/2), sin(<i>a</i>/2) * (<i>x, y, z</i>)). Also recall that every 3D orientation can be uniquely specified by a single 3D rotation by some angle around some axis.
    <br><br>
    
    All MJCF elements that have spatial frames allow the five attributes listed below. The frame orientation is specified using at most one of these attributes. The <span>quat</span> attribute has a default value corresponding to the null rotation, while the others are initialized in the special undefined state. Thus if none of these attributes are specified by the user, the frame is not rotated.
</p>

<dl>
    <dt><b>quat :</b> real(4), "1 0 0 0"</dt>
    <dd>If the quaternion is known, this is the preferred was to specify the frame orientation because it does not involve conversions. Instead it is normalized to unit length and copied into mjModel during compilation. When a model is saved as MJCF, all frame orientations are expressed as quaternions using this attribute.</dd>

    <dt><b>axisangle :</b> real(4), optional</dt>
    <dd>These are the quantities (<i>x, y, z, a</i>) mentioned above. The last number is the angle of rotation, in degrees or radians as specified by the <span>angle</span> attribute of <a href="http://mujoco.org/book/modeling.html#compiler">compiler</a>. The first three numbers determine a 3D vector which is the rotation axis. This vector is normalized to unit length during compilation, so the user can specify a vector of any non-zero length. Keep in mind that the rotation is right-handed; if the direction of the vector (<i>x, y, z</i>) is reversed this will result in the opposite rotation. Changing the sign of <i>a</i> can also be used to specify the opposite rotation.</dd>

    <dt><b>euler :</b> real(3), optional</dt>
    <dd>Rotation angles around three coordinate axes. The sequence of axes around which these rotations are applied is determined by the <span>eulerseq</span> attribute of <a href="http://mujoco.org/book/modeling.html#compiler">compiler</a> and is the same for the entire model.</dd>
    
    <dt><b>xyaxes :</b> real(6), optional</dt>
    <dd>The first 3 numbers are the X axis of the frame. The next 3 numbers are the Y axis of the frame, which is automatically made orthogonal to the X axis. The Z axis is then defined as the cross-product of the X and Y axes.</dd>

    <dt><b>zaxis :</b> real(3), optional</dt>
    <dd>The Z axis of the frame. The compiler finds the minimal rotation that maps the vector (0,0,1) into the vector specified here. This determines the X and Y axes of the frame implicitly. This is useful for geoms with rotational symmetry around the Z axis, as well as lights - which are oriented along the Z axis of their frame.</dd>
</dl>


<h4 id="CSolver">Solver parameters</h4>
<p>
    The solver <a href="http://mujoco.org/book/computation.html#soParameters">Parameters</a> section of the Computation chapter explained the mathematical and algorithmic meaning of the quantities d, b, k which determine the behavior of the constraints in MuJoCo. Here we explain how to set them. Setting is done indirectly, through the attributes <span>solref</span> and <span>solimp</span> which are available in all MJCF elements involving constraints. These parameters can be adjusted per constraint, or per defaults class, or left undefined - in which case MuJoCo uses the internal defaults shown below. Note also the override mechanism available in <a href="http://mujoco.org/book/modeling.html#option">option</a>; it can be used to change all contact-related solver parameters at runtime, so as to experiment interactively with parameter settings or implement continuation methods for numerical optimization.
    <br><br>

    Here we focus on a single scalar constraint. Using slightly different notation from the Computation chapter, let a1 denote the acceleration, v the velocity, r the position or residual (defined as 0 in friction dimensions), b and k the stiffness and damping of the virtual spring used to define the reference acceleration a* = - b v - k r, d the constraint impedance, and a0 the acceleration in the absence of constraint force. Our earlier analysis revealed that the dynamics in constraint space are approximately
    <br><br>

    a1 + d (b v + k r) = (1 - d) a0
    <br><br>

    Again, the parameters that are under the user's control are d, b, k. The remaining quantities are functions of the system state and are computed automatically at each time step.
    <br><br>

    First we explain the setting of the impedance d. Recall that d must lie between 0 and 1; internally MuJoCo clamps it to the range [<a href="http://mujoco.org/book/reference.html#glNumeric">mjMINIMP mjMAXIMP</a>] which is currently set to [0.0001 0.9999]. It causes the solver to interpolate between the unforced acceleration a0 and reference acceleration a*. Small values of d correspond to soft/weak constraints while large values of d correspond to strong/hard constraints. The user can set d to a constant, or take advantage of its interpolating property and make it position-dependent, i.e. a function of r. Position-dependent impedance can be used to model soft contact layers around objects, or define equality constraint that become stronger with larger violation (so as to approximate backlash for example). The shape of the function d(r) is determined by the element-specific parameter vector <span>solimp</span> and the global settings <span>impedance</span> and <span>impratio</span> which are attributes of <a href="http://mujoco.org/book/modeling.html#option">option</a>.
</p> 

<dl>
    <dt><b>solimp : </b> real(3), "0.9 0.95 0.001"</dt>
    <dd>
        The three numbers are (dmin, dmax, width). They parameterize the function d(r). The shape of this function also depends on the global impedance type shown in the labels in each subplot below. The sigmoid (which is the internal default) is composed of two quadratic pieces that join smoothly. The quantity r is computed as follows. For equality constraints, r equals the constraint violation which can be either positive or negative. For friction loss or friction dimensions of elliptic cones, r is always 0. For limits, normal directions of elliptic cones and all directions of pyramidal cones, r is the (limit or contact) distance minus the margin at which the constraint becomes active; for contacts this margin is actually margin-gap. Therefore limit and contact constraints are active when the corresponding r is negative. Note that the impedance function depends on the absolute value of r and not on r itself.
        <br><br>

        <img src="./modeling_files/impedance.png" width="650">
    </dd>
</dl>

<p>
    Next we explain the setting of the stiffness k and damping b. The idea here is to re-parameterize the model in terms of the time constant and damping ratio of the above mass-spring-damper system. By "time constant" we mean the inverse of the natural frequency times the damping ratio. Constraints whose residual is identically 0 have first-order dynamics and the mass-spring-damper analysis does not apply. In that case the time constant is the rate of exponential decay of the constraint velocity, and the damping ratio is ignored.
</p>

<dl>
    <dt><b>solref : </b> real(2), "0.02 1"</dt>
    <dd>
        The two numbers are (timeconst, dampratio). Note that the effective stiffness d(r) k and damping d(r) b are scaled by the impedance d(r) which is a function of the distance r. Thus we cannot always achieve the specified mass-spring-damper properties, unless we completely undo the scaling by d. But this is undesirable because it would ruin the above interpolating property, in particular the limit d = 0 would no longer disable the constraint. Instead we scale the stiffness and damping so that the damping ratio remains constant, while the time constant increases when d(r) gets smaller. The scaling formulas implemented in MuJoCo are
        <br><br>

        b = 2 / (dmax * timeconst)
        <br>
        k = d(r) / (dmax * dmax * timeconst * timeconst * dampratio * dampratio)
        <br><br>

        The timeconst parameter should be at least two times larger than the simulation time step, otherwise the system can become too stiff relative to the numerical integrator (especially when Euler integration is used) and the simulation can go unstable. This is enforced internally, unless the <span>refsafe</span> attribute of <a href="http://mujoco.org/book/modeling.html#option-flag">flag</a> is set to false. The dampratio parameter would normally be set to 1, corresponding to critical damping. Smaller values result in under-damped or bouncy constraints, while larger values result in over-damped constraints. Under-damping is related to restitution. However our analysis of the constraint dynamics is already approximate and based on a special case (since in general we do not know what solution will be found by the numerical solver). Thus we leave it to the user to adjust the constraint parameters empirically so as to achieve a desired restitution effect. 
    </dd>
</dl>


<h4 id="CAlgorithms">Algorithms and related settings</h4>
<p>
    The computation of constraint forces and constrained accelerations involves solving an optimization problem numerically. MuJoCo has three algorithms for solving this optimization problem: CG, Newton, PGS. Each of them can be applied to a pyramidal or elliptic model of the friction cones, and with dense or sparse constraint Jacobians. In addition, the user can specify the maximum number of iterations, and tolerance level which controls early termination. There is also a second Noslip solver, which is a post-processing step enabled by specifying a positive number of noslip iterations. All these algorithm settings can be specified in the <a href="http://mujoco.org/book/modeling.html#option">option</a> element.
    <br><br>

    The default settings work well for most models, but in some cases it is necessary to tune the algorithm. The best way to do this is to experiment with the relevant settings and use the visual profiler in simulate.cpp as well as HAPTIX, which shows the timing of different computations as well as solver statistics per iteration. We can offer the following general guidelines and observations:   
</p>

<ul>
    <li>
        The constraint Jacobian should be dense for small models and sparse for large models. The default setting is 'auto'; it resolves to dense when the number of degrees of freedom is up to 60, and sparse over 60. Note however that the threshold is better defined in terms of number of active constraints, which is model and behavior dependent.
    </li>
    <br>

    <li>
        The choice between pyramidal and elliptic friction cones is a modeling choice rather than an algorithmic choice, i.e. it leads to a different optimization problem solved with the same algorithms. Elliptic cones correspond more closely to physical reality. However pyramidal cones can improve the performance of the algorithms - but not necessarily. While the default is pyramidal, we recommend trying the elliptic cones. When contact slip is a problem, the best way to suppress it is to use elliptic cones, large impratio, and the Newton algorithm with very small tolerance. If that is not sufficient, enable the Noslip solver.
    </li>
    <br>

    <li>
        The Newton algorithm is the best choice for most models. It has quadratic convergence near the global minimum and gets there in surprisingly few iterations - usually around 5, and rarely more than 20. It should be used with aggressive tolerance values, say 1e-10, because it is capable of achieving high accuracy without added delay (due to quadratic convergence at the end). The only situation where we have seen it slow down are large models with elliptic cones and many slipping contacts. In that regime the Hessian factorization needs a lot of updates. It may also slow down in some large models with unfortunate ordering of model elements that results in high fill-in (computing the optimal elimination order is NP-hard, so we are relying on a heuristic). Note that the number of non-zeros in the factorized Hessian can be monitored in the profiler.
    </li>
    <br>

    <li>
        The CG algorithm works well in the situation described above where Newton slows down. In general CG shows linear convergence with a good rate, but it cannot compete with Newton in terms of number of iterations, especially when high accuracy is desired. However its iterations are much faster, and are not affected by fill-in or increased complexity due to elliptic cones. If Newton proves to be too slow, try CG next.
    </li>
    <br>

    <li>
        The PGS solver used to be the default solver until recently, and was substantially improved in MuJoCo 1.50 by making it work with sparse models. However we have not yet found a situation where it is the best algorithm, which is not to say that such situations do not exist. PGS solves a constrained optimization problem and has sub-linear convergence in our experience, however it usually makes rapid progress on the first few iterations. So it is a good choice when inaccurate solutions can be tolerated. For systems with large mass ratios or other model properties causing poor conditioning, PGS convergence tends to be rather slow. Keep in mind that PGS performs sequential updates, and therefore breaks symmetry in systems where the physics should be symmetric. In contrast, CG and Newton perform parallel updates and preserve symmetry.
    </li>
    <br>

    <li>
        The Noslip solver is a modified PGS solver. It is executed as a post-processing step after the main solver (which can be Newton, CG or PGS). The main solver updates all unknowns. In contrast, the Noslip solver updates only the constraint forces in friction dimensions, and ignores constraint regularization. This has the effect of suppressing the drift or slip caused by the soft-constraint model. However, this cascade of optimization steps is no longer solving a well-defined optimization problem (or any other problem); instead it is just an adhoc mechanism. While it usually does its job, we have seen some instabilities in models with more complex interactions among multiple contacts.
    </li>
    <br>

    <li>
        PGS has a setup cost (in terms of CPU time) for computing the inverse inertia in constraint space. Similarly, Newton has a setup cost for the initial factorization of the Hessian, and incurs additional factorization costs depending on how many factorization updates are needed later. CG does not have any setup cost. Since the Noslip solver is also a PGS solver, the PGS setup cost will be paid whenever Noslip is enabled, even if the main solver is CG or Newton. The setup operation for the main PGS and Noslip PGS is the same, thus the setup cost is paid only once when both are enabled.
    </li>

</ul>


<h4 id="COverride">Contact override</h4>
<p> 
    MuJoCo uses an elaborate as well as novel <a href="http://mujoco.org/book/computation.html#Constraint">Constraint model</a> described in the Computation chapter. Gaining an intuition for how this model works requires some experimentation. In order to facilitate this process, we provide a mechanism to override some of the solver parameters, without making changes to the actual model. Once the override is disabled, the simulation reverts to the parameters specified in the model. Note that the Option dialog in HAPTIX exposes all relevant settings and makes it easy to experiment with changes interactively. This mechanism can also be used to implement continuation methods in the context of numerical optimization (such as optimal control or state estimation). This is done by allowing contacts to act from a distance in the early phases of optimization - so as to help the optimizer find a gradient and get close to a good solution - and reducing this effect later to make the final solution physically realistic.
    <br><br>

    The relevant settings here are the <span>override</span> attribute of <a href="http://mujoco.org/book/modeling.html#option-flag">flag</a> which enables and disables this mechanism, and the <span>o_margin</span>, <span>o_solref</span>, <span>o_solimp</span> attributes of <a href="http://mujoco.org/book/modeling.html#option">option</a> which specify the new solver parameters. Note that the override applies only to contacts, and not to other types of constraints. In principle there are many real-valued parameters in a MuJoCo model that could benefit from a similar override mechanism. However we had to draw a line somewhere, and contacts are the natural choice because they give rise to the richest yet most difficult-to-tune behavior. Furthermore, contact dynamics often present a challenge in terms of numerical optimization, and experience has shown that continuation over contact parameters can help avoid local minima.
</p>


<h4 id="CUser">User parameters</h4>
<p> 
    A number of MJCF elements have the optional attribute <span>user</span>, which defines a custom element-specific parameter array. This interacts with the corresponding "nuser_XXX" attribute of the <a href="http://mujoco.org/book/modeling.html#size">size</a> element. If for example we set <span>nuser_geom</span> to 5, then every geom in mjModel will have a custom array of 5 real-valued parameters. These geom-specific parameters are either defined in the MJCF file via the <span>user</span> attribute of <a href="http://mujoco.org/book/modeling.html#geom">geom</a>, or set to 0 by the compiler if this attribute is omitted. MuJoCo does not use these parameters in any internal computations; instead they are available for custom computations. The parser allows arrays of arbitrary length in the XML, and the compiler later resizes them to length nuser_XXX.
    <br><br>

    Some element-specific parameters that are normally used in internal computations can also be used in custom computations. This is done by installing user callbacks which override parts of the simulation pipeline. For example, the <a href="http://mujoco.org/book/modeling.html#general">general</a> actuator element has attributes <span>dyntype</span> and <span>dynprm</span>. If <span>dyntype</span> is set to "user", then MuJoCo will call <a href="http://mujoco.org/book/reference.html#mjcb_act_dyn">mjcb_act_dyn</a> to compute the actuator dynamics instead of calling its internal function. The user function pointed to by <a href="http://mujoco.org/book/reference.html#mjcb_act_dyn">mjcb_act_dyn</a> can interpret the parameters defined in <span>dynprm</span> however it wishes. However the length of this parameter array cannot be changed (unlike the custom arrays described earlier whose length is defined in the MJCF file). The same applies to other callbacks.
    <br><br>

    In addition to the element-specific user parameters described above, one can include global data in the model via <a href="http://mujoco.org/book/modeling.html#custom">custom</a> elements. For data that change in the course of the simulation, there is also the array mjData.userdata whose size is determined by the <span>nuserdata</span> attribute of the <a href="http://mujoco.org/book/modeling.html#size">size</a> element.
</p>


<h4 id="CActuator">Actuator shortcuts</h4>
<p> 
    As explained in the <a href="http://mujoco.org/book/computation.html#geActuation">Actuation model</a> section of the Computation chapter, MuJoCo offers a flexible actuator model with transmission, activation dynamics and force generation components that can be specified independently. The full functionality can be accessed via the XML element <a href="http://mujoco.org/book/modeling.html#general">general</a> which allows the user to create a variety of custom actuators. In addition, MJCF provides shortcuts for configuring common actuators. This is done via the XML elements <a href="http://mujoco.org/book/modeling.html#motor">motor</a>, <a href="http://mujoco.org/book/modeling.html#position">position</a>, <a href="http://mujoco.org/book/modeling.html#velocity">velocity</a>, <a href="http://mujoco.org/book/modeling.html#cylinder">cylinder</a>, <a href="http://mujoco.org/book/modeling.html#muscle">muscle</a>. These are <i>not</i> separate model elements. Internally MuJoCo supports only one actuator type - which is why when an MJCF model is saved all actuators are written as <span class="el">general</span>. Shortcuts create general actuators implicitly, set their attributes to suitable values, and expose a subset of attributes with possibly different names. For example, <span class="el">position</span> creates a position servo with attribute <span>kp</span> which is the servo gain. However <span class="el">general</span> does not have an attribute <span>kp</span>. Instead the parser adjusts the gain and bias parameters of the general actuator in a coordinated way so as to mimic a position servo. The same effect could have been achieved by using <span class="el">general</span> directly, and setting its attributes to certain values as described below.
    <br><br>

    Actuator shortcuts also interact with defaults. Recall that the <a href="http://mujoco.org/book/modeling.html#CDefault">default setting</a> mechanism involves classes, each of which has a complete collection of dummy elements (one of each element type) used to initialize the attributes of the actual model elements. In particular, each defaults class has only one general actuator element. What happens if we specify <span class="el">position</span> and later <span class="el">velocity</span> in the same defaults class? The XML elements are processed in order, and the attributes of the single general actuator are set every time an actuator-related element is encountered. Thus <span class="el">velocity</span> has precedence. If however we specify <span class="el">general</span> in the defaults class, it will only set the attributes that are given explicitly, and leave the rest unchanged. A similar complication arises when creating actual model elements. Suppose the active defaults class specified <span class="el">position</span>, and now we create an actuator using <span class="el">general</span> and omit some of its attributes. The missing attributes will be set to whatever values are used to model a position servo, even though this actuator may not be intended as a position servo.
    <br><br>

    In light of these potential complications, we recommend a simple approach: use the same actuator shortcut in both the defaults class and in the creation of actual model elements. If a given model requires different actuators, either create multiple defaults classes, or avoid using defaults for actuators and instead specify all their attributes explicitly.
</p>


<h4 id="CLengthRange">Actuator length range</h4>
<p> 
	As of MuJoCo 2.0, the field mjModel.actuator_lengthrange contains the range of feasible actuator lengths (or more precisely, lengths of the actuator's transmission). This is needed to simulate <a href="http://mujoco.org/book/modeling.html#CMuscle">muscle actuators</a> as explained below. Here we focus on what actuator_lengthrange means and how to set it.
	<br><br>

	Unlike all other fields of mjModel which are exact physical or geometric quantities, actuator_lengthrange is an approximation. Intuitively it corresponds to the minimum and maximum length that the actuator's transmission can reach over all "feasible" configurations of the model. However MuJoCo constraints are soft, so in principle any configuration is feasible. Yet we need a well-defined range for muscle modeling. There are three ways to set this range: (1) provide it explicitly using the new attribute <span class="attr">lengthrange</span> available in all actuators; (2) copy it from the limits of the joint or tendon to which the actuator is attached; (3) compute it automatically, as explained in the rest of this section. There are many options here, controlled with the new XML element <a href="http://mujoco.org/book/modeling.html#compiler-lengthrange">lengthrange</a>.
	<br><br>

	Automatic computation of actuator length ranges is done at compile time, and the results are stored in mjModel.actuator_lengthrange of the compiled model. If the model is then saved (either as XML or MJB), the computation does not need to be repeated at the next load. This is important because the computation can slow down the model compiler with large musculo-skeletal models. Indeed we have made the compiler multi-threaded just to speed up this operation (different actuators are processed in parallel in different threads). Incidentally, this is why the flag '-pthread' is now needed when linking user code against the MuJoCo library on Linux and macOS.
	<br><br>

	Automatic computation relies on modified physics simulation. For each actuator we apply force (negative when computing the minimum, positive when computing the maximum) through the actuator's transmission, advance the simulation in a damped regime avoiding instabilities, give it enough time to settle and record the result. This is related to gradient descent with momentum, and indeed we have experimented with explicit gradient-based optimization, but the problem is that it is not clear what objective we should be optimizing (given the mix of soft constraints). By using simulation, we are essentially letting the physics tell us what to optimize. Keep in mind though that this is still an optimization process, and as such it has parameters that may need to be adjusted. We provide conservative defaults which should work with most models, but if they don't, use the attributes of <a href="http://mujoco.org/book/modeling.html#compiler-lengthrange">lengthrange</a> for fine-tuning.
</p>


<h4 id="CMuscle">Muscle actuators</h4>
<p> 
	As of MuJoCo 2.0, we provide a set of tools for modeling biological muscles. Users who want to add muscles with minimum effort can do so with a single line of XML in the actuator section:
</p>

<pre class="prettyprint prettyprinted" style=""><span class="tag">&lt;actuator&gt;</span><span class="pln">
    </span><span class="tag">&lt;muscle</span><span class="pln"> </span><span class="atn">name</span><span class="pun">=</span><span class="atv">"mymuscle"</span><span class="pln"> </span><span class="atn">tendon</span><span class="pun">=</span><span class="atv">"mytendon"</span><span class="tag">&gt;</span><span class="pln">
</span><span class="tag">&lt;/actuator&gt;</span></pre>

<p>
    Biological muscles look very different from each other, yet behave in remarkably similar ways once certain scaling is applied. Our default settings apply such scaling, which is why one can obtain a reasonable muscle model without adjusting any parameters. Constructing a more detailed model will of course require parameter adjustment, as explained in this section. 
    <br><br>

    Keep in mind that even though the muscle model is quite elaborate, it is still a type of MuJoCo actuator and obeys the same conventions as all other actuators. A muscle can be defined using <a href="http://mujoco.org/book/modeling.html#general">general</a>, but the shortcut <a href="http://mujoco.org/book/modeling.html#muscle">muscle</a> is more convenient. As with all other actuators, the force production mechanism and the transmission are defined independently. Nevertheless, muscles only make (bio)physical sense when attached to tendon or joint transmissions. For concreteness we will assume a tendon transmission here.
    <br><br>

    First we discuss length and length scaling. The range of feasible lengths of the transmission (i.e. MuJoCo tendon) will play an important role; see <a href="http://mujoco.org/book/modeling.html#CLengthRange">Length range</a> section above. In biomechanics, a muscle and a tendon are attached in series and form a muscle-tendon actuator. Our convention is somewhat different: in MuJoCo the entity that has spatial properties (in particular length and velocity) is the tendon, while the muscle is an abstract force-generating mechanism that pulls on the tendon. Thus the tendon length in MuJoCo corresponds to the muscle+tendon length in biomechanics. We assume that the biological tendon is inelastic, with constant length LT, while the biological muscle length LM varies over time. The MuJoCo tendon length is the sum of the biological muscle and tendon lengths:
    <br><br>

    actuator_length = LT + LM
    <br><br>

    Another important constant is the optimal resting length of the muscle, denoted L0. It equals the length LM at which the muscle generates maximum active force at zero velocity. We do not ask the user to specify L0 and LT directly, because it is difficult to know their numeric values given the spatial complexity of the tendon routing and wrapping. Instead we compute L0 and LT automatically as follows. The length range computation described above already provided the operating range for LT + LM. In addition, we ask the user to specify the operating range for the muscle length LM scaled by the (still unknown) constant L0. This is done with the attribute <span class="attr">range</span>; the default scaled range is (0.75, 1.05). Now we can compute the two constants, using the fact that the actual and scaled ranges have to map to each other:
    <br><br>

	(actuator_lengthrange[0] - LT) / L0 = range[0]<br>    
	(actuator_lengthrange[1] - LT) / L0 = range[1]
    <br><br>

    At runtime, we compute the scaled muscle length and velocity as:
    <br><br>

    L = (actuator_length - LT) / L0<br>
    V = actuator_velocity / L0
    <br><br>

    The advantage of the scaled quantities is that all muscles behave similarly in that representation. The behavior is captured by the Force-Length-Velocity (FLV) function measured in many experimental papers. We approximate this function as follows:
    <br><br>

    <img src="./modeling_files/musclemodel.png" width="650">
    <br><br>

    The function is in the form:
    <br><br>

    FLV(L, V, act) = FL(L)*FV(V)*act + FP(L)
    <br><br>

    Comparing to the general form of a MuJoCo actuator, we see that FL*FV is the actuator gain and FP is the actuator bias. FL is the active force as a function of length, while FV is the active force as a function of velocity. They are multiplied to obtain the overall active force (note the scaling by act which is the actuator activation). FP is the passive force which is always present regardless of activation. The output of the FLV function is the scaled muscle force. We multiply the scaled force by a muscle-specific constant F0 to obtain the actual force:
    <br><br>

    actuator_force = - FLV(L, V, act) * F0
    <br><br>

    The negative sign is because positive muscle activation generates pulling force. The constant F0 is the peak active force at zero velocity. It is related to the muscle thickness (i.e. physiological cross-sectional area or PCSA). If known, it can be set with the attribute <span class="attr">force</span> of element <a href="http://mujoco.org/book/modeling.html#muscle">muscle</a>. If it is not known, we set it to -1 which is the default. In that case we rely on the fact that larger muscles tend to act on joints that move more weight. The attribute <span class="attr">scale</span> defines this relationship as:
    <br><br>

    F0 = scale / actuator_acc0
    <br><br>

    The quantity actuator_acc0 is precomputed by the model compiler. It is the norm of the joint acceleration caused by unit force acting on the actuator transmission. Intuitively, scale determines how strong the muscle is "on average" while its actual strength depends on the geometric and inertial properties of the entire model.
    <br><br>

    Thus far we encountered three constants that define the properties of an individual muscle: LT, L0, F0. In addition, the function FLV itself has several parameters illustrated in the above figure: lmin, lmax, vmax, fpmax, fvmax. These are supposed to be the same for all muscles, however different experimental papers suggest different shapes of the FLV function, thus users familiar with that literature may want to adjust them. We provide the MATLAB function <a href="http://mujoco.org/book/source/FLV.m">FLV.m</a> which was used to generate the above figure and shows how we compute the FLV function.
    <br><br>

    Before embarking on a mission to design more accurate FLV functions, consider the fact that the operating range of the muscle has a bigger effect than the shape of the FLV function, and in many cases this parameter is unknown. Below is a graphical illustration:
    <br><br>

    <img src="./modeling_files/musclerange.png" width="400">
    <br><br>

    This figure format is common in the biomechanics literature, showing the operating range of each muscle superimposed on the normalized FL curve (ignore the vertical displacement). Our default range is shown in black. The blue curves are experimental data for two arm muscles. One can find muscles with small range, large range, range spanning the ascending portion of the FL curve, or the descending portion, or some of both. Now suppose you have a model with 50 muscles. Do you believe that someone did careful experiments and measured the operating range for every muscle in your model, taking into account all the joints that the muscle spans? If not, then it is better to think of musculo-skeletal models as having the same general behavior as the biological system, while being different in various details - including details that are of great interest to some research community. For most muscle properties which modelers consider constant and known, there is an experimental paper showing that they vary under some conditions. This is not to discourage people from building accurate models, but rather to discourage people from believing too strongly in their models. Modeling in biology is quite different from modeling in physics and engineering... which is why we find it ironic when people in Robotics complain that building accurate robot models is hard.
    <br><br>

    Coming back to our muscle model, there is the muscle activation act. This is the state of a first-order nonlinear filter whose input is the control signal. The filter dynamics are:
    <br><br>
    
    d act / dt = (ctrl - act) / tau(ctrl, act)
    <br><br>

    Internally the control signal is clamped to [0, 1] even if the actuator does not have a control range specified. There are two time constants specified with the attribute <span class="attr">timeconst</span>, namely timeconst = (tau_act, tau_deact) with defaults (0.01, 0.04). The effective time constant tau is then computed at runtime as:
    <br><br>

    tau(ctrl, act) = tau_act * (0.5 + 1.5*act), if ctrl &gt; act<br>
    tau(ctrl, act) = tau_deact / (0.5 + 1.5*act), if ctrl &lt;= act
    <br><br>

    Now we summarize the attributes of element <a href="http://mujoco.org/book/modeling.html#muscle">muscle</a> which users may want to adjust, depending on their familiarity with the biomechanics literature and availability of detailed measurements with regard to a particular model:
</p>

<dl>
    <dt>
        Defaults
    </dt>
    <dd>
        Use the built-in defaults everywhere. All you have to do is attach a muscle to a tendon, as shown at the beginning of this section. This yields a generic yet reasonable model.
    </dd>

    <dt>
        scale
    </dt>
    <dd>
        If you do not know the strength of individual muscles but want to make all muscles stronger or weaker, adjust scale. This can be adjusted separately for each muscle, but it makes more sense to set it once in the <a href="http://mujoco.org/book/modeling.html#default">default</a> element.
    </dd>

    <dt>
        force
    </dt>
    <dd>
        If you know the peak active force F0 of the individual muscles, enter it here. Many experimental papers contain this data.
    </dd>

    <dt>
        range
    </dt>
    <dd>
        The operating range of the muscle in scaled lengths is also available in some papers. It is not clear how reliable such measurements are (given that muscles act on many joints) but they do exist. Note that the range differs substantially between muscles.
    </dd>

    <dt>
        timeconst
    </dt>
    <dd>
        Muscles are composed of slow-twitch and fast-twitch fibers. The typical muscle is mixed, but some muscles have a higher proportion of one or the other fiber type, making them faster or slower. This can be modeled by adjusting the time constants. The vmax parameter of the FLV function should also be adjusted accordingly.
    </dd>

    <dt>
        lmin, lmax, vmax, fpmax, fvmax
    </dt>
    <dd>
        These are the parameters controlling the shape of the FLV function. Advanced users can experiment with them; see MATLAB function <a href="http://mujoco.org/book/source/FLV.m">FLV.m</a>. Similar to the scale setting, if you want to change the FLV parameters for all muscles, do so in the <a href="http://mujoco.org/book/modeling.html#default">default</a> element.
    </dd>

    <dt>
        Custom model
    </dt>
    <dd>
    	Instead of adjusting the parameters of our muscle model, users can implement a different model, by setting <span class="attr">gaintype</span>, <span class="attr">biastype</span> and <span class="attr">dyntype</span> of a <a href="http://mujoco.org/book/modeling.html#general">general</a> actuator to "user" and providing callbacks at runtime. Or, leave some of these types set to "muscle" and use our model, while replacing the other components. Note that tendon geometry computations are still handled by the standard MuJoCo pipeline providing actuator_length, actuator_velocity and actuator_lengthrange as inputs to the user's muscle model. Custom callbacks could then simulate elastic tendons or any other detail we have chosen to omit.
    </dd>
</dl>

<p>
    <b>Relation to OpenSim</b>
    <br><br>

    The standard software used by researchers in biomechanics is OpenSim. We have designed our muscle model to be similar to the OpenSim model where possible, while making simplifications which result in significantly faster and more stable simulations. To help MuJoCo users convert OpenSim models, here we summarize the similarities and differences.
    <br><br>

    The activation dynamics model is identical to OpenSim, including the default time constants.
    <br><br>

    The FLV function is not exactly the same, but both MuJoCo and OpenSim approximate the same experimental data, so they are very close. For a description of the OpenSim model and summary of relevant experimental data, see:
    <br><br>
    Millard et al, "Flexing computational muscle: modeling and simulation of musculotendon dynamics", J Biomech Eng. 2013 Feb;135(2)
    <br><br>

    We assume inelastic tendons while OpenSim can model tendon elasticity. We decided not to do that here, because tendon elasticity requires fast-equilibrium assumptions which in turn require various tweaks and are prone to simulation instability. In practice tendons are quite stiff, and their effect can be captured approximately by stretching the FL curve corresponding to the inelastic case (Zajac 89). This can be done in MuJoCo by shortening the muscle operating range.
    <br><br>

    Pennation angle (i.e. the angle between the muscle and the line of force) is not modeled in MuJoCo and is assumed to be 0. This effect can be approximated by scaling down the muscle force and also adjusting the operating range.
    <br><br>

    Tendon wrapping is also more limited in MuJoCo. We allow spheres and infinite cylinders as wrapping objects, and require two wrapping objects to be separated by a fixed site in the tendon path. This is to avoid the need for iterative computations of tendon paths. As of MuJoCo 2.0 we also allow "side sites" to be placed inside the sphere or cylinder, which causes an inverse wrap: the tendon path is constrained to pass through the object instead of go around it. This can replace torus wrapping objects used in OpenSim to keep the tendon path within a given area. Overall, tendon wrapping is the most challenging part of converting an OpenSim model to a MuJoCo model, and requires some manual work. On the bright side, there is a small number of high-quality OpenSim models in use, so once they are converted we are done.
    <br><br>

    Below we illustrate the four types of tendon wrapping available in MuJoCo 2.0. Note that the curved sections of the wrapping tendons are rendered as straight, but the geometry pipeline works with the actual curves and computes their lengths and moments analytically:
    <br><br>

    <img src="./modeling_files/tendonwraps.png" width="500">   
</p>


<h4 id="CSensor">Sensors</h4>
<p> 
    MuJoCo can simulate a wide variety of sensors as described in the <a href="http://mujoco.org/book/modeling.html#sensor">sensor</a> element below. User sensor types can also be defined, and are evaluated by the callback <a href="http://mujoco.org/book/reference.html#mjcb_sensor">mjcb_sensor</a>. Sensors do not affect the simulation. Instead their outputs are copied in the array mjData.sensordata and are available for user processing.
    <br><br>

    Here we describe the XML attributes common to all sensor types, so as to avoid repetition later.
</p>

<dl>
    <dt><b>name :</b> string, optional</dt>
    <dd>
        Name of the sensor.
    </dd>

    <dt><b>noise :</b> real, "0"</dt>
    <dd>
        The standard deviation of zero-mean Gaussian noise added to the sensor output, when the <span>sensornoise</span> attribute of <a href="http://mujoco.org/book/modeling.html#option-flag">flag</a> is enabled. Sensor noise respects the sensor data type: quaternions and unit vectors remain normalized, non-negative quantities remain non-negative.
    </dd>

    <dt><b>cutoff :</b> real, "0"</dt>
    <dd>
        When this value is positive, it limits the absolute value of the sensor output. It is also used to normalize the sensor output in the sensor data plots in HAPTIX and simulate.cpp.
    </dd>

    <dt><b>user :</b> real(nuser_sensor), "0 0 ..."</dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CUser">User parameters</a>.        
    </dd>
</dl>



<h4 id="CInclude">Including files</h4>
<p> 
    MJCF files can include other XML files using the <a href="http://mujoco.org/book/modeling.html#include">include</a> element. Mechanistically, the parser replaces the DOM node corresponding to the include element in the master file with the list of XML elements that are children of the top-level element in the included file. The top-level element itself is discarded, because it is a grouping element for XML purposes and would violate the MJCF format if included.
    <br><br>

    This functionality enables modular MJCF models; see the MPL family of models in the model library. One example of modularity is constructing a model of a robot (which tends to be elaborate) and then including it in multiple "scenes", i.e. MJCF models defining the objects in the robot's environment. Another example is creating a file with commonly used assets (say materials with carefully adjusted rgba values) and including it in multiple models which reference those assets.
    <br><br>

    The included files are not required to be valid MJCF files on their own, but they usually are. Indeed we have designed this mechanism to allow MJCF models to be included in other MJCF models. To make this possible, repeated MJCF sections are allowed even when that does not make sense semantically in the context of a single model. For example, we allow the kinematic tree to have multiple roots (i.e. multiple <span class="el">worldbody</span> elements) which are merged automatically by the parser. Otherwise including robots into scenes would be impossible.
    <br><br>

    The flexibility of repeated MCJF sections comes at a price: global settings that apply to the entire model, such as the <span>angle</span> attribute of <a href="http://mujoco.org/book/modeling.html#compiler">compiler</a> for example, can be defined multiple times. MuJoCo allows this, and uses the last definition encountered in the composite model, after all include elements have been processed. So if model A is defined in degrees and model B is defined in radians, and A is included in B after the <span class="el">compiler</span> element in B, the entire composite model will be treated as if it was defined in degrees - leading to undesirable consequences in this case. The user has to make sure that models included in each other are compatible in this sense; local vs. global coordinates is another compatibility requirement.
    <br><br>

    Finally, as explained next, element names must be unique among all elements of the same type. So for example if the same geom name is used in two models, and one model is included in the other, this will result in compile error. Including the same XML file more than once is a parsing error. The reason for this restriction is that we want to avoid repeated element names as well as infinite recursion caused by inclusion.
</p>


<h4 id="CName">Naming elements</h4>
<p>
    Most model elements in MJCF can have names. They are defined with the attribute <span>name</span> of the corresponding XML element. When a given model element is named, its name must be unique among all elements of the same type. Names are case-sensitive. They are used at compile time to reference the corresponding element, and are also saved in mjModel for user convenience at runtime.
    <br><br>

    The name is usually an optional attribute. We recommend leaving it undefined (so as to keep the model file shorter) unless there is a specific reason to define it. There can be several such reasons:
</p>

<ul>
    <li>
        Some model elements need to reference other elements as part of their creation. For example, a spatial tendon needs to reference sites in order to specify the via points it passes through. Referencing can only be done by name. Note that assets exist for the sole purpose of being referenced, so they must have a name, however it can be omitted and set implicitly from the corresponding file name.
    </li>
    <br>

    <li>
        The visualizer offers the option to label all model elements of a given type. When a name is available, it is printed next to the object in the 3D view; otherwise a generic label in the format "body 7" is printed.
    </li>
    <br>

    <li>
        The function <a href="http://mujoco.org/book/reference.html#mj_name2id">mj_name2id</a> returns the index of the model element with given type and name. Conversely, the function <a href="http://mujoco.org/book/reference.html#mj_id2name">mj_id2name</a> returns the name given the index. This is useful for custom computations involving a model element that is identified by its name in the XML (as opposed to relying on a fixed index which can change when the model is edited).
    </li>
    <br>

    <li>
        The model file could in principle become more readable by naming certain elements. Keep in mind however that XML itself has a commenting mechanism, and that mechanism is more suitable for achieving readability - especially since most text editors provide syntax highlighting which detects XML comments.
    </li>
</ul>


<h4 id="CURDF">URDF extensions</h4>
<p> 
    The Unified Robot Description Format (URDF) is a popular XML file format in which many existing robots have been modeled. This is why we have implemented support for URDF even though it can only represent a subset of the model elements available in MuJoCo. In addition to standard URDF files, MuJoCo can load files that have a custom (from the viewpoint of URDF) <span class="el">mujoco</span> element as a child of the top-level element <span class="el">robot</span>. This custom element can have sub-elements <a href="http://mujoco.org/book/modeling.html#compiler">compiler</a>, <a href="http://mujoco.org/book/modeling.html#option">option</a>, <a href="http://mujoco.org/book/modeling.html#size">size</a> with the same functionality as in MJFC, except that the default compiler settings are modified so as to accomodate the URDF modeling convention. The <a href="http://mujoco.org/book/modeling.html#compiler">compiler</a> extension in particular has proven very useful, and indeed several of its attributes were introduced because a number of existing URDF models have non-physical dynamics parameters which MuJoCo's built-in compiler will reject if left unmodified. This extension is also needed to specify mesh directories.
    <br><br>

    Note that the while MJCF models are checked against a custom XML schema by the parser, URDF models are not. Even the MuJoCo-specific elements emebdded in the URDF file are not checked. As a result, mis-typed attribute names are silently ignored, which can result in major confusion if the typo remains unnoticed.
    <br><br>

    Here is an example extension section of a URDF model:
</p>

<pre class="prettyprint prettyprinted" style=""><span class="tag">&lt;robot</span><span class="pln"> </span><span class="atn">name</span><span class="pun">=</span><span class="atv">"darwin"</span><span class="tag">&gt;</span><span class="pln">
    </span><span class="tag">&lt;mujoco&gt;</span><span class="pln">
        </span><span class="tag">&lt;compiler</span><span class="pln"> </span><span class="atn">meshdir</span><span class="pun">=</span><span class="atv">"../mesh/darwin/"</span><span class="pln"> </span><span class="atn">balanceinertia</span><span class="pun">=</span><span class="atv">"true"</span><span class="tag">/&gt;</span><span class="pln">
    </span><span class="tag">&lt;/mujoco&gt;</span><span class="pln">
    </span><span class="tag">&lt;link</span><span class="pln"> </span><span class="atn">name</span><span class="pun">=</span><span class="atv">"MP_BODY"</span><span class="tag">&gt;</span><span class="pln">
        ...
</span><span class="tag">&lt;/robot&gt;</span></pre>

<p>
    The above extensions make URDF more usable but still limited. If the user wants to build models taking full advantage of MuJoCo and at the same time maintain URDF compatibility, we recommend the following procedure. Introduce extensions in the URDF as needed, load it and save it as MJCF. Then add information to the MJCF using <a href="http://mujoco.org/book/modeling.html#include">include</a> elements whenever possible. In this way, if the URDF is modified, the corresponding MJCF can be easily re-created. In our experience though, URDF files tend to be static while MJCF files are often edited. Thus in practice it is usually sufficient to convert the URDF to MJCF once and after that only work with the MJCF.
</p>


<h2 id="Summary">MJCF Summary</h2>


<h4 id="CSchema">XML schema</h4>
<p> 
    The table below summarizes the XML elements and their attributes in MJCF. It is generated automatically with the function <a href="http://mujoco.org/book/reference.html#mj_printSchema">mj_printSchema</a> which prints out the custom schema used by the parser to validate the model file. The same table can be viewed in the Help dialog in HAPTIX. Note that all information in MJCF is entered through elements and attributes. Text content in elements is not used; if present, the parser ignores it. The symbols in the second column of the table have the following meaning:
    <br><br>
    
    <table>
    <tbody><tr><td class="sym"><b>!</b></td><td class="sym">required element, can appear only once</td></tr>
    <tr><td class="sym"><b>?</b></td><td class="sym">optional element, can appear only once</td></tr>
    <tr><td class="sym"><b>*</b></td><td class="sym">optional element, can appear many times</td></tr>
    <tr><td class="sym"><b>R</b></td><td class="sym">optional element, can appear many times recursively</td></tr>
    </tbody></table>
    <br>


<table border="1">
<tbody><tr>
    <td style="padding-left:5" bgcolor="#EEEEEE" class="el">mujoco</td>
    <td class="ty">!</td>
    <td class="at">model </td>
</tr>
<tr>
    <td style="padding-left:20" bgcolor="#EEEEEE" class="el">compiler</td>
    <td class="ty">*</td>
    <td class="at">boundmass boundinertia settotalmass balanceinertia strippath coordinate angle fitaabb eulerseq meshdir texturedir discardvisual convexhull inertiafromgeom inertiagrouprange </td>
</tr>
<tr>
    <td style="padding-left:20" bgcolor="#EEEEEE" class="el">option</td>
    <td class="ty">*</td>
    <td class="at">timestep apirate impratio tolerance noslip_tolerance mpr_tolerance gravity wind density viscosity o_margin o_solref o_solimp integrator collision impedance reference cone jacobian solver iterations noslip_iterations mpr_iterations </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">flag</td>
    <td class="ty">?</td>
    <td class="at">constraint equality frictionloss limit contact passive gravity clampctrl warmstart filterparent actuation refsafe override energy fwdinv sensornoise </td>
</tr>
<tr>
    <td style="padding-left:20" bgcolor="#EEEEEE" class="el">size</td>
    <td class="ty">*</td>
    <td class="at">njmax nconmax nstack nuserdata nkey nuser_body nuser_jnt nuser_geom nuser_site nuser_cam nuser_tendon nuser_actuator nuser_sensor </td>
</tr>
<tr>
    <td style="padding-left:20" bgcolor="#EEEEEE" class="el">visual</td>
    <td class="ty">*</td>
    <td class="at"><span style="color:black"><i>no attributes</i></span></td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">global</td>
    <td class="ty">?</td>
    <td class="at">fovy ipd linewidth glow offwidth offheight </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">quality</td>
    <td class="ty">?</td>
    <td class="at">shadowsize offsamples numslices numstacks numarrows numquads </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">headlight</td>
    <td class="ty">?</td>
    <td class="at">ambient diffuse specular active </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">map</td>
    <td class="ty">?</td>
    <td class="at">stiffness stiffnessrot force torque alpha fogstart fogend znear zfar shadowclip shadowscale </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">scale</td>
    <td class="ty">?</td>
    <td class="at">forcewidth contactwidth contactheight connect com camera light selectpoint jointlength jointwidth actuatorlength actuatorwidth framelength framewidth constraint slidercrank </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">rgba</td>
    <td class="ty">?</td>
    <td class="at">fog force inertia joint actuator com camera light selectpoint connect contactpoint contactforce contactfriction contacttorque constraint slidercrank crankbroken </td>
</tr>
<tr>
    <td style="padding-left:20" bgcolor="#EEEEEE" class="el">statistic</td>
    <td class="ty">*</td>
    <td class="at">meaninertia meanmass meansize extent center </td>
</tr>
<tr>
    <td style="padding-left:20" bgcolor="#EEEEEE" class="el">default</td>
    <td class="ty">R</td>
    <td class="at">class </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">mesh</td>
    <td class="ty">?</td>
    <td class="at">scale </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">material</td>
    <td class="ty">?</td>
    <td class="at">texture emission specular shininess reflectance rgba texrepeat texuniform </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">joint</td>
    <td class="ty">?</td>
    <td class="at">type pos axis springdamper limited solreflimit solimplimit solreffriction solimpfriction stiffness range margin ref springref armature damping frictionloss user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">geom</td>
    <td class="ty">?</td>
    <td class="at">type pos quat contype conaffinity condim group size material friction mass density solmix solref solimp margin gap fromto axisangle xyaxes zaxis euler hfield mesh fitscale rgba user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">site</td>
    <td class="ty">?</td>
    <td class="at">type group pos quat material size axisangle xyaxes zaxis euler rgba user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">camera</td>
    <td class="ty">?</td>
    <td class="at">fovy ipd pos quat axisangle xyaxes zaxis euler mode user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">light</td>
    <td class="ty">?</td>
    <td class="at">pos dir directional castshadow active attenuation cutoff exponent ambient diffuse specular mode </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">pair</td>
    <td class="ty">?</td>
    <td class="at">condim friction solref solimp gap margin </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">equality</td>
    <td class="ty">?</td>
    <td class="at">active solref solimp </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">tendon</td>
    <td class="ty">?</td>
    <td class="at">limited range solreflimit solimplimit solreffriction solimpfriction frictionloss width material margin stiffness damping rgba user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">general</td>
    <td class="ty">?</td>
    <td class="at">ctrllimited forcelimited ctrlrange forcerange gear cranklength user dyntype gaintype biastype dynprm gainprm biasprm </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">motor</td>
    <td class="ty">?</td>
    <td class="at">ctrllimited forcelimited ctrlrange forcerange gear cranklength user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">position</td>
    <td class="ty">?</td>
    <td class="at">ctrllimited forcelimited ctrlrange forcerange gear cranklength user kp </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">velocity</td>
    <td class="ty">?</td>
    <td class="at">ctrllimited forcelimited ctrlrange forcerange gear cranklength user kv </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">cylinder</td>
    <td class="ty">?</td>
    <td class="at">ctrllimited forcelimited ctrlrange forcerange gear cranklength user timeconst area diameter bias </td>
</tr>
<tr>
    <td style="padding-left:20" bgcolor="#EEEEEE" class="el">custom</td>
    <td class="ty">*</td>
    <td class="at"><span style="color:black"><i>no attributes</i></span></td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">numeric</td>
    <td class="ty">*</td>
    <td class="at">name size data </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">text</td>
    <td class="ty">*</td>
    <td class="at">name data </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">tuple</td>
    <td class="ty">*</td>
    <td class="at">name </td>
</tr>
<tr>
    <td style="padding-left:50" bgcolor="#EEEEEE" class="el">element</td>
    <td class="ty">*</td>
    <td class="at">objtype objname prm </td>
</tr>
<tr>
    <td style="padding-left:20" bgcolor="#EEEEEE" class="el">asset</td>
    <td class="ty">*</td>
    <td class="at"><span style="color:black"><i>no attributes</i></span></td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">texture</td>
    <td class="ty">*</td>
    <td class="at">name type file gridsize gridlayout fileright fileleft fileup filedown filefront fileback builtin rgb1 rgb2 mark markrgb random width height </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">hfield</td>
    <td class="ty">*</td>
    <td class="at">name file nrow ncol size </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">mesh</td>
    <td class="ty">*</td>
    <td class="at">name class file scale </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">material</td>
    <td class="ty">*</td>
    <td class="at">name class texture texrepeat texuniform emission specular shininess reflectance rgba </td>
</tr>
<tr>
    <td style="padding-left:20" bgcolor="#EEEEEE" class="el">(world)body</td>
    <td class="ty">R</td>
    <td class="at">name childclass pos quat mocap axisangle xyaxes zaxis euler user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">inertial</td>
    <td class="ty">?</td>
    <td class="at">pos quat mass diaginertia axisangle xyaxes zaxis euler fullinertia </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">joint</td>
    <td class="ty">*</td>
    <td class="at">name class type pos axis springdamper limited solreflimit solimplimit solreffriction solimpfriction stiffness range margin ref springref armature damping frictionloss user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">freejoint</td>
    <td class="ty">*</td>
    <td class="at">name </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">geom</td>
    <td class="ty">*</td>
    <td class="at">name class type contype conaffinity condim group size material friction mass density solmix solref solimp margin gap fromto pos quat axisangle xyaxes zaxis euler hfield mesh fitscale rgba user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">site</td>
    <td class="ty">*</td>
    <td class="at">name class type group pos quat material size axisangle xyaxes zaxis euler rgba user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">camera</td>
    <td class="ty">*</td>
    <td class="at">name class fovy ipd pos quat axisangle xyaxes zaxis euler mode target user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">light</td>
    <td class="ty">*</td>
    <td class="at">name class directional castshadow active pos dir attenuation cutoff exponent ambient diffuse specular mode target </td>
</tr>
<tr>
    <td style="padding-left:20" bgcolor="#EEEEEE" class="el">contact</td>
    <td class="ty">*</td>
    <td class="at"><span style="color:black"><i>no attributes</i></span></td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">pair</td>
    <td class="ty">*</td>
    <td class="at">class geom1 geom2 condim friction solref solimp gap margin </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">exclude</td>
    <td class="ty">*</td>
    <td class="at">body1 body2 </td>
</tr>
<tr>
    <td style="padding-left:20" bgcolor="#EEEEEE" class="el">equality</td>
    <td class="ty">*</td>
    <td class="at"><span style="color:black"><i>no attributes</i></span></td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">connect</td>
    <td class="ty">*</td>
    <td class="at">name class body1 body2 anchor active solref solimp </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">weld</td>
    <td class="ty">*</td>
    <td class="at">name class body1 body2 active solref solimp </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">joint</td>
    <td class="ty">*</td>
    <td class="at">name class joint1 joint2 polycoef active solref solimp </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">tendon</td>
    <td class="ty">*</td>
    <td class="at">name class tendon1 tendon2 polycoef active solref solimp </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">distance</td>
    <td class="ty">*</td>
    <td class="at">name class geom1 geom2 distance active solref solimp </td>
</tr>
<tr>
    <td style="padding-left:20" bgcolor="#EEEEEE" class="el">tendon</td>
    <td class="ty">*</td>
    <td class="at"><span style="color:black"><i>no attributes</i></span></td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">spatial</td>
    <td class="ty">*</td>
    <td class="at">name class limited range solreflimit solimplimit solreffriction solimpfriction frictionloss width material margin stiffness damping rgba user </td>
</tr>
<tr>
    <td style="padding-left:50" bgcolor="#EEEEEE" class="el">site</td>
    <td class="ty">*</td>
    <td class="at">site </td>
</tr>
<tr>
    <td style="padding-left:50" bgcolor="#EEEEEE" class="el">geom</td>
    <td class="ty">*</td>
    <td class="at">geom sidesite </td>
</tr>
<tr>
    <td style="padding-left:50" bgcolor="#EEEEEE" class="el">pulley</td>
    <td class="ty">*</td>
    <td class="at">divisor </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">fixed</td>
    <td class="ty">*</td>
    <td class="at">name class limited range solreflimit solimplimit solreffriction solimpfriction frictionloss margin stiffness damping user </td>
</tr>
<tr>
    <td style="padding-left:50" bgcolor="#EEEEEE" class="el">joint</td>
    <td class="ty">*</td>
    <td class="at">joint coef </td>
</tr>
<tr>
    <td style="padding-left:20" bgcolor="#EEEEEE" class="el">actuator</td>
    <td class="ty">*</td>
    <td class="at"><span style="color:black"><i>no attributes</i></span></td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">general</td>
    <td class="ty">*</td>
    <td class="at">name class ctrllimited forcelimited ctrlrange forcerange gear cranklength user joint jointinparent tendon slidersite cranksite site dyntype gaintype biastype dynprm gainprm biasprm </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">motor</td>
    <td class="ty">*</td>
    <td class="at">name class ctrllimited forcelimited ctrlrange forcerange gear cranklength user joint jointinparent tendon slidersite cranksite site </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">position</td>
    <td class="ty">*</td>
    <td class="at">name class ctrllimited forcelimited ctrlrange forcerange gear cranklength user joint jointinparent tendon slidersite cranksite site kp </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">velocity</td>
    <td class="ty">*</td>
    <td class="at">name class ctrllimited forcelimited ctrlrange forcerange gear cranklength user joint jointinparent tendon slidersite cranksite site kv </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">cylinder</td>
    <td class="ty">*</td>
    <td class="at">name class ctrllimited forcelimited ctrlrange forcerange gear cranklength user joint jointinparent tendon slidersite cranksite site timeconst area diameter bias </td>
</tr>
<tr>
    <td style="padding-left:20" bgcolor="#EEEEEE" class="el">sensor</td>
    <td class="ty">*</td>
    <td class="at"><span style="color:black"><i>no attributes</i></span></td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">touch</td>
    <td class="ty">*</td>
    <td class="at">name site cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">accelerometer</td>
    <td class="ty">*</td>
    <td class="at">name site cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">velocimeter</td>
    <td class="ty">*</td>
    <td class="at">name site cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">gyro</td>
    <td class="ty">*</td>
    <td class="at">name site cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">force</td>
    <td class="ty">*</td>
    <td class="at">name site cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">torque</td>
    <td class="ty">*</td>
    <td class="at">name site cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">magnetometer</td>
    <td class="ty">*</td>
    <td class="at">name site cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">rangefinder</td>
    <td class="ty">*</td>
    <td class="at">name site cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">jointpos</td>
    <td class="ty">*</td>
    <td class="at">name joint cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">jointvel</td>
    <td class="ty">*</td>
    <td class="at">name joint cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">tendonpos</td>
    <td class="ty">*</td>
    <td class="at">name tendon cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">tendonvel</td>
    <td class="ty">*</td>
    <td class="at">name tendon cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">actuatorpos</td>
    <td class="ty">*</td>
    <td class="at">name actuator cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">actuatorvel</td>
    <td class="ty">*</td>
    <td class="at">name actuator cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">actuatorfrc</td>
    <td class="ty">*</td>
    <td class="at">name actuator cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">ballquat</td>
    <td class="ty">*</td>
    <td class="at">name joint cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">ballangvel</td>
    <td class="ty">*</td>
    <td class="at">name joint cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">framepos</td>
    <td class="ty">*</td>
    <td class="at">name objtype objname cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">framequat</td>
    <td class="ty">*</td>
    <td class="at">name objtype objname cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">framexaxis</td>
    <td class="ty">*</td>
    <td class="at">name objtype objname cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">frameyaxis</td>
    <td class="ty">*</td>
    <td class="at">name objtype objname cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">framezaxis</td>
    <td class="ty">*</td>
    <td class="at">name objtype objname cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">framelinvel</td>
    <td class="ty">*</td>
    <td class="at">name objtype objname cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">frameangvel</td>
    <td class="ty">*</td>
    <td class="at">name objtype objname cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">framelinacc</td>
    <td class="ty">*</td>
    <td class="at">name objtype objname cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">frameangacc</td>
    <td class="ty">*</td>
    <td class="at">name objtype objname cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">subtreecom</td>
    <td class="ty">*</td>
    <td class="at">name body cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">subtreelinvel</td>
    <td class="ty">*</td>
    <td class="at">name body cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">subtreeangmom</td>
    <td class="ty">*</td>
    <td class="at">name body cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">user</td>
    <td class="ty">*</td>
    <td class="at">name objtype objname datatype needstage dim cutoff noise user </td>
</tr>
<tr>
    <td style="padding-left:20" bgcolor="#EEEEEE" class="el">keyframe</td>
    <td class="ty">*</td>
    <td class="at"><span style="color:black"><i>no attributes</i></span></td>
</tr>
<tr>
    <td style="padding-left:35" bgcolor="#EEEEEE" class="el">key</td>
    <td class="ty">*</td>
    <td class="at">time qpos qvel act </td>
</tr>
</tbody></table>

</p>


<h4 id="CType">Attribute types</h4>
<p>
    Each attribute has a data type enforced by the parser. The available data types are:
    <br><br>

    <table border="1">
    <tbody><tr>
        <td class="el1">string &nbsp;&nbsp;</td>
        <td>An arbitrary string, usually specifying a file name or a user-defined name of a model element.</td>
    </tr>
    
    <tr>
        <td class="el1">int(N)</td>
        <td>An array of N integers. If N is omitted it equals 1.</td>
    </tr>
    
    <tr>
        <td class="el1">real(N)</td>
        <td>An array of N real-valued numbers. If N is omitted it equals 1.</td>
    </tr>

    <tr>
        <td class="el1">[...]</td>
        <td>Keyword attribute. The list of valid keywords is given in brackets.</td>
    </tr>   
    </tbody></table>
    <br>

    For array-type attributes, the length of the array is enforced by the parser unless specified otherwise in the reference documentation below.
    <br><br>

    In addition to having a data type, attributes can be required or optional. Optional attributes can have internal defaults or not. Optional attributes that do not have internal defaults are initialized in a special undefined state. This state is different from any valid setting that can be entered in the XML. This mechanism enables the compiler to determine if the attribute has been "touched" by the user, either explicitly or through defaults, and take appropriate action. Some attributes have internal defaults (usually 0) which are not actually allowed by the compiler. When such attributes become relevant in a given context, they must be set to allowed values.
    <br><br>

    <table border="1">
    <tbody><tr>
        <td class="el1">required &nbsp;&nbsp;</td>
        <td>The attribute is required by the parser. If it is not present the parser will generate an error.</td>
    </tr>
    
    <tr>
        <td class="el1">optional</td>
        <td>The attribute is optional. There is no internal default. The attribute is initialized in the undefined state.</td>
    </tr>
    
    <tr>
        <td class="el1">"..."</td>
        <td>The attribute is optional. The internal default is given in quotes.</td>
    </tr>  
    </tbody></table>
    <br>

    In the reference documentation below the attribute name is shown in boldface, followed by its data type, followed by the required/optional status including the internal default if any. For example, the attribute <span>angle</span> is a keyword attribute whose value can be "radian" or "degree". It is an optional attribute and has internal default "degree". Therefore it will appear in the reference documentation as
</p>

<dl>
    <dt><b>angle :</b> [radian, degree], "degree"</dt>
</dl>


<h4 id="CKeyword">Keyword lists</h4>
<p>
    The following table summarizes the keyword lists that can be used in keyword-type attributes. When several attributes use the same keyword list and appear in the same elements, they are grouped together.
    <br><br>

    <table border="1">
    <tbody><tr>
        <td class="el1">Elements</td>
        <td class="el1" width="60%">Attributes</td>
        <td class="el1">Keyword list</td>
    </tr>

    <tr>
        <td class="el">compiler</td>
        <td class="at">balanceinertia, strippath, fitaabb, discardvisual, convexhull</td>
        <td class="at1">false, true</td>
    </tr>

    <tr>
        <td class="el">compiler</td>
        <td class="at">angle</td>
        <td class="at1">radian, degree</td>
    </tr>

    <tr>
        <td class="el">compiler</td>
        <td class="at">inertiafromgeom</td>
        <td class="at1">false, true, auto</td>
    </tr>

    <tr>
        <td class="el">compiler</td>
        <td class="at">coordinate</td>
        <td class="at1">local, global</td>
    </tr>

    <tr>
        <td class="el">option</td>
        <td class="at">integrator</td>
        <td class="at1">Euler, RK4</td>
    </tr>

    <tr>
        <td class="el">option</td>
        <td class="at">collision</td>
        <td class="at1">all, predefined, dynamic</td>
    </tr>

    <tr>
        <td class="el">option</td>
        <td class="at">impedance</td>
        <td class="at1">constant, sigmoid, linear, user</td>
    </tr>

    <tr>
        <td class="el">option</td>
        <td class="at">reference</td>
        <td class="at1">spring, user</td>
    </tr>

    <tr>
        <td class="el">option</td>
        <td class="at">solver</td>
        <td class="at1">PGS, CG, Newton</td>
    </tr>

    <tr>
        <td class="el">option</td>
        <td class="at">cone</td>
        <td class="at1">pyramidal, elliptic</td>
    </tr>

    <tr>
        <td class="el">option</td>
        <td class="at">jacobian</td>
        <td class="at1">dense, sparse, auto</td>
    </tr>
    
    <tr>
        <td class="el">flag</td>
        <td class="at">constraint, equality, frictionloss, limit, contact, passive, gravity, clampctrl, warmstart, filterparent, actuation, refsafe, override, energy, fwdinv, sensornoise</td>
        <td class="at1">disable, enable</td>
    </tr>

    <tr>
        <td class="el">texture</td>
        <td class="at">type</td>
        <td class="at1">2d, cube, skybox</td>
    </tr>

    <tr>
        <td class="el">texture</td>
        <td class="at">builtin</td>
        <td class="at1">none, gradient, checker, flat</td>
    </tr>

    <tr>
        <td class="el">texture</td>
        <td class="at">mark</td>
        <td class="at1">none, edge, cross, random</td>
    </tr>

    <tr>
        <td class="el">material</td>
        <td class="at">texuniform</td>
        <td class="at1">false, true</td>
    </tr>

    <tr>
        <td class="el">body</td>
        <td class="at">mocap</td>
        <td class="at1">false, true</td>
    </tr>

    <tr>
        <td class="el">joint</td>
        <td class="at">type</td>
        <td class="at1">free, ball, slide, hinge</td>
    </tr>

    <tr>
        <td class="el">geom</td>
        <td class="at">type</td>
        <td class="at1">plane, hfield, sphere, capsule, ellipsoid, cylinder, box, mesh</td>
    </tr>

    <tr>
        <td class="el">site</td>
        <td class="at">type</td>
        <td class="at1">sphere, capsule, ellipsoid, cylinder, box</td>
    </tr>

    <tr>
        <td class="el">joint<br>tendon</td>
        <td class="at">limited</td>
        <td class="at1">false, true</td>
    </tr>

    <tr>
        <td class="el">light</td>
        <td class="at">directional, castshadow, active</td>
        <td class="at1">false, true</td>
    </tr>

    <tr>
        <td class="el">light<br>camera</td>
        <td class="at">mode</td>
        <td class="at1">fixed, track, trackcom, targetbody, targetbodycom</td>
    </tr>

    <tr>
        <td class="el">equality</td>
        <td class="at">active</td>
        <td class="at1">false, true</td>
    </tr>

    <tr>
        <td class="el">motor<br>cylinder<br>position<br>velocity<br>general</td>
        <td class="at">ctrllimited, forcelimited</td>
        <td class="at1">false, true</td>
    </tr>

    <tr>
        <td class="el">general</td>
        <td class="at">dyntype</td>
        <td class="at1">none, integrator, filter, user</td>
    </tr>

    <tr>
        <td class="el">general</td>
        <td class="at">gaintype</td>
        <td class="at1">fixed, user</td>
    </tr>

    <tr>
        <td class="el">general</td>
        <td class="at">biastype</td>
        <td class="at1">none, affine, user</td>
    </tr>

    <tr>
        <td class="el">sensor</td>
        <td class="at">needstage</td>
        <td class="at1">none, pos, vel, acc</td>
    </tr>

    <tr>
        <td class="el">sensor</td>
        <td class="at">datatype</td>
        <td class="at1">real, positive, axis, quaternion</td>
    </tr>

    <tr>
        <td class="el">element</td>
        <td class="at">objtype</td>
        <td class="at1">body, joint, geom, site, camera, light, mesh, hfield, texture, material, equality, tendon, actuator, sensor, numeric, text, tuple</td>
    </tr>
    </tbody></table>
</p>




<h2 id="Reference">MJCF Reference</h2>
<p> 
    MJCF files have a unique top-level element <a href="http://mujoco.org/book/modeling.html#mujoco">mujoco</a>. The next-level elements are referred to as <i>sections</i>. They are all optional. Some sections are merely used for grouping and have no attributes. Sections can be repeated, to facilitate merging of models via the <a href="http://mujoco.org/book/modeling.html#include">include</a> element.
    <br><br>
    
    The <i>order</i> of attributes within an element can be arbitrary. The order of child elements within a parent element can also be arbitrary, with four exceptions:
</p>

<ul>
    <li>
        The order of <a href="http://mujoco.org/book/modeling.html#joint">joint</a> elements within a <a href="http://mujoco.org/book/modeling.html#body">body</a> matters because joint transformations are performed in sequence. 
    </li>
    <li>
        The order of elements in a <a href="http://mujoco.org/book/modeling.html#spatial">spatial</a> tendon matters because it determines the sequence of objects that the tendon passes through or wraps around. 
    </li>
    <li>
        The order of repeated sections matters when the same attribute is set multiple times to different values. In that case the last setting takes effect for the entire model.
    </li>
    <li>
        The order of multiple actuator shortcuts in the same defaults class matters, because each shortcut sets the attributes of the single <a href="http://mujoco.org/book/modeling.html#general">general</a> element in that defaults class, overriding the previous settings. 
    </li>
</ul>

<p>
    In the remainder of this chapter we describe all valid MJCF elements and their attributes. Some elements can be used in multiple contexts, in which case their meaning depends on the parent element. This is why we always show the parent as a prefix in the documentation below.
 </p>

<h3 id="include"><b>include</b> (*)</h3>
<p>
    This element does not strictly speaking belong to MJCF. Instead it is a meta-element, used to assemble multiple XML files in a single document object model (DOM) before parsing. The included file must be a valid XML file with a unique top-level element. This top-level element is removed by the parser, and the elements below it are inserted at the location of the <span class="el">include</span> element. At least one element must be inserted as a result of this procedure. The <span class="el">include</span> element can be used where ever an XML element is expected in the MJFC file. Nested includes are allowed, however a given XML file can be included at most once in the entire model. After all the included XML files have been assembled into a single DOM, it must correspond to a valid MJCF model. Other than that, it is up to the user to decide how to use includes and how to modularize large files if desired.
</p>

<dl>
    <dt><b>file :</b> string, required</dt>
    <dd>The name of the XML file to be included. The file location is relative to the directory of the main MJCF file. If the file is not in the same directory, it should be prefixed with a relative path.</dd>
</dl>


<h3 id="mujoco"><b>mujoco</b> (!)</h3>
<p>
    The unique top-level element, identifying the XML file as an MJCF model file.
</p>

<dl>
    <dt><b>model :</b> string, "MuJoCo Model"</dt>
    <dd>The name of the model. This name is shown in the title bar of MuJoCo HAPTIX.</dd>
</dl>


<h3 id="compiler"><b>compiler</b> (*)</h3>
<p>
    This element is used to set options for the built-in parser and compiler. After parsing and compilation it no longer has any effect. The settings here are global and apply to the entire model.
</p>

<dl>
    <dt><b>boundmass :</b> real, "0"</dt>
    <dd>
        This attribute imposes a lower bound on the mass of each body except for the world body. It can be used as a quick fix for poorly designed models that contain massless moving bodies, such as the dummy bodies often used in URDF models to attach sensors. Note that in MuJoCo there is no need to create dummy bodies.
    </dd>

    <dt><b>boundinertia :</b> real, "0"</dt>
    <dd>
        This attribute imposes a lower bound on the diagonal inertia components of each body except for the world body. Its use is similar to <span>boundmass</span> above.
    </dd>

    <dt><b>settotalmass :</b> real, "-1"</dt>
    <dd>
        If this value is positive, the compiler will scale the masses and inertias of all bodies in the model, so that the total mass equals the value specified here. The world body has mass 0 and does not participate in any mass-related computations. This scaling is performed last, after all other operations affecting the body mass and inertia. The same scaling operation can be applied at runtime to the compiled mjModel with the function <a href="http://mujoco.org/book/reference.html#mj_setTotalmass">mj_setTotalmass</a>.
    </dd>

    <dt><b>balanceinertia :</b> [false, true], "false"</dt>
    <dd>
        A valid diagonal inertia matrix must satisfy A+B&gt;=C for all permutations of the three diagonal elements. Some poorly designed models violate this constraint, which will normally result in compile error. If this attribute is set to "true", the compiler will silently set all three diagonal elements to their average value whenever the above condition is violated.
    </dd>

    <dt><b>strippath :</b> [false, true], "false" for MJCF, "true" for URDF</dt>
    <dd>
        The this attribute is "true", the parser will remove any path information in file names specified in the model. This is useful for loading models created on a different system using a different directory structure.
    </dd>

    <dt><b>coordinate :</b> [local, global], "local" for MJCF, always "local" for URDF</dt>
    <dd>
        This attribute specifies whether the frame positions and orientations in the MJCF model are expressed in local or global coordinates; recall <a href="http://mujoco.org/book/modeling.html#CFrame">Coordinate frames</a>. The compiler converts global into local coordinates, and mjModel always uses local coordinates. For URDF models the parser sets this attribute to "local" internally, regardless of the XML setting.
    </dd>

    <dt><b>angle :</b> [radian, degree], "degree" for MJCF, always "radian" for URDF</dt>
    <dd>
        This attribute specifies whether the angles in the MJCF model are expressed in units of degrees or radians. The compiler converts degrees into radians, and mjModel always uses radians. For URDF models the parser sets this attribute to "radian" internally, regardless of the XML setting.
    </dd>

    <dt><b>fitaabb :</b> [false, true], "false"</dt>
    <dd>
        The compiler is able to replace a mesh with a geometric primitive fitted to that mesh; see <a href="http://mujoco.org/book/modeling.html#geom">geom</a> below. If this attribute is "true", the fitting procedure uses the axis-aligned bounding box (aabb) of the mesh. Otherwise it uses the equivalent-inertia box of the mesh. The type of geometric primitive used for fitting is specified separately for each geom.
    </dd>

    <dt><b>eulerseq :</b> string, "xyz"</dt>
    <dd>
        This attribute specifies the sequence of Euler rotations for all <span>euler</span> attributes of elements that have spatial frames, as explained in <a href="http://mujoco.org/book/modeling.html#COrientation">Frame orientations</a>. This must be a string with exactly 3 characters from the set {'x', 'y', 'z', 'X', 'Y', 'Z'}. The character at position n determines the axis around which the n-th rotation is performed. Lower case denotes axes that rotate with the frame, while upper case denotes axes that remain fixed in the parent frame. The "rpy" convention used in URDF corresponds to the default "xyz" in MJCF.
    </dd>

    <dt><b>meshdir :</b> string, optional</dt>
    <dd>
        This attribute instructs the compiler where to look for mesh and height field files. The full path to a file is determined as follows. If the <span>strippath</span> attribute described above is "true", all path information from the file name is removed. The following checks are then applied in order: (1) if the file name contains an absolute path, it is used without further changes; (2) if this attribute is set and contains an absolute path, the full path is the string given here appended with the file name; (3) the full path is the path to the main MJCF model file, appended with the value of this attribute if specified, appended with the file name.
    </dd>

    <dt><b>texturedir :</b> string, optional</dt>
    <dd>
        This attribute is used to instruct the compiler where to look for texture files. It works in the same way as <span>meshdir</span> above.
    </dd>

    <dt><b>discardvisual :</b> [false, true], "false" for MJCF, "true" for URDF</dt>
    <dd>
        This attribute instructs the parser to discard "visual geoms", defined as geoms whose <span>contype</span> and <span>conaffinity</span> attributes are both set to 0. This functionality is useful for models that contain two sets of geoms, one for collisions and the other for visualization. Note that URDF models are usually constructed in this way. It rarely makes sense to have two sets of geoms in the model, especially since MuJoCo uses convex hulls for collisions, so we recommend using this feature to discard redundant geoms. Keep in mind however that geoms considered visual per the above definition can still participate in collisions, if they appear in the explicit list of contact <a href="http://mujoco.org/book/modeling.html#pair">pairs</a>. The parser does not check this list before discarding geoms; it relies solely on the geom attributes to make the determination.
    </dd>

    <dt><b>convexhull :</b> [false, true], "true"</dt>
    <dd>
        If this attribute is "true", the compiler will automatically generate a convex hull for every mesh that is used in at least one non-visual geom (in the sense of the <span>discardvisual</span> attribute above). This is done to speed up collision detection; recall <a href="http://mujoco.org/book/computation.html#Collision">Collision detection</a> section in the Computation chapter. Even if the mesh is already convex, the hull contains edge information that is not present in the mesh file, so it needs to be constructed. The only reason to disable this feature is to speed up re-loading of a model with large meshes during model editing (since the convex hull computation is the slowest operation performed by the compiler). However once model design is finished, this feature should be enabled, because the availability of convex hulls substantially speeds up collision detection with large meshes.
    </dd>

    <dt><b>inertiafromgeom :</b> [false, true, auto], "auto"</dt>
    <dd>
        This attribute controls the automatic inference of body masses and inertias from geoms attached to the body. If this setting is "false", no automatic inference is performed. In that case each body must have explicitly defined mass and inertia with the <a href="http://mujoco.org/book/modeling.html#inertial">inertial</a> element, or else a compile error will be generated. If this setting is "true", the mass and inertia of each body will be inferred from the geoms attached to it, overriding any values specified with the <span class="el">inertial</span> element. The default setting "auto" means that masses and inertias are inferred automatically only when the <span class="el">inertial</span> element is missing in the body definition. One reason to set this attribute to "true" instead of "auto" is to override inertial data imported from a poorly designed model. In particular, a number of publicly available URDF models have seemingly arbitrary inertias which are too large compared to the mass. This results in equivalent inertia boxes which extend far beyond the geometric boundaries of the model. Note that the built-in OpenGL visualizer can render equivalent inertia boxes.
    </dd>

    <dt><b>inertiagrouprange :</b> int(2), "0 4"</dt>
    <dd>
        This attribute specifies the range of geom groups that are used to infer body masses and inertias (when such inference is enabled). The <span>group</span> attribute of <a href="http://mujoco.org/book/modeling.html#geom">geom</a> is an integer. If this integer falls in the range specified here, the geom will be used in the inertial computation, otherwise it will be ignored. This feature is useful in models that have redundant sets of geoms for collision and visualization. Note that the world body does not participate in the inertial computations, so any geoms attached to it are automatically ignored. Therefore it is not necessary to adjust this attribute and the geom-specific groups so as to exclude world geoms from the inertial computation.
    </dd>
</dl>



<h3 id="compiler-lengthrange">compiler/ <b>lengthrange</b> (?)</h3>
<p>
    To be written.
</p>



<h3 id="option"><b>option</b> (*)</h3>
<p>
    This element is is one-to-one correspondence with the low level structure mjOption contained in the field mjModel.opt of mjModel. These are simulation options and do not affect the compilation process in any way; they are simply copied into the low level model. Even though mjOption can be modified by the user at runtime, it is nevertheless a good idea to adjust it properly through the XML.
</p>

<dl>
    <dt><b>timestep :</b> real, "0.002"</dt>
    <dd>
        Simulation time step in seconds. This is the single most important parameter affecting the speed-accuracy trade-off which is inherent in every physics simulation. Smaller values result in better accuracy and stability. To achieve real-time performance, the time step must be larger than the CPU time per step (or 4 times larger when using the RK4 integrator). The CPU time is measured with internal timers and can be displayed in both HAPTIX and Pro. It should be monitored when adjusting the time step. MuJoCo can simulate most robotic systems a lot faster than real-time, however models with many floating objects (resulting in many contacts) are more demanding computationally. Keep in mind that stability is determined not only by the time step but also by the <a href="http://mujoco.org/book/modeling.html#CSolver">Solver parameters</a>; in particular softer constraints can be simulated with larger time steps. When fine-tuning a challenging model, it is recommended to experiment with both settings jointly. In optimization-related applications, real-time is no longer good enough and instead it is desirable to run the simulation as fast as possible. In that case the time step should be made as large as possible.
    </dd>

    <dt><b>apirate :</b> real, "100"</dt>
    <dd>
        This parameter determines the rate (in Hz) at which the socket API in HAPTIX allows the update function to be executed. This mechanism is used to simulate devices with limited communication bandwidth. It only affects the socket API and not the physics simulation.
    </dd>

    <dt><b>gravity :</b> real(3), "0 0 -9.81"</dt>
    <dd>
        Gravitational acceleration vector. In the default world orientation the Z-axis points up. The MuJoCo GUI is organized around this convention (both the camera and perturbation commands are based on it) so we do not recommend deviating from it.
    </dd>

    <dt><b>wind :</b> real(3), "0 0 0"</dt>
    <dd>
        Velocity vector of the medium (i.e. wind). This vector is subtracted from the 3D translational velocity of each body, and the result is used to compute viscous, lift and drag forces acting on the body; recall <a href="http://mujoco.org/book/computation.html#gePassive">Passive forces</a> in the Computation chapter. The magnitude of these forces scales with the values of the next two attributes.
    </dd>

    <dt><b>magnetic :</b> real(3), "0 -0.5 0"</dt>
    <dd>
        Global magnetic flux. This vector is used by magnetometer sensors, which are defined as sites and return the magnetic flux at the site position expressed in the site frame.
    </dd>

    <dt><b>density :</b> real, "0"</dt>
    <dd>
        Density of the medium, not to be confused with the geom density used to infer masses and inertias. This parameter is used to simulate lift and drag forces, which scale quadratically with velocity. In SI units the density of air is around 1.2 while the density of water is around 1000 depending on temperature. Setting density to 0 disables lift and drag forces.
    </dd>

    <dt><b>viscosity :</b> real, "0"</dt>
    <dd>
        Viscosity of the medium. This parameter is used to simulate viscous forces, which scale linearly with velocity. In SI units the viscosity of air is around 0.00002 while the viscosity of water is around 0.0009 depending on temperature. Setting viscosity to 0 disables viscous forces. Note that the Euler <a href="http://mujoco.org/book/computation.html#geIntegration">integrator</a> handles damping in the joints implicitly - which improves stability and accuracy. It does not presently do this with body viscosity. Therefore, if the goal is merely to create a damped simulation (as opposed to modeling the specific effects of viscosity), we recommend using joint damping rather than body viscosity. There is a plan to develop an integrator that is fully implicit in velocity, which will make joint damping and body viscosity equally stable, but this feature is not yet available.
    </dd>

    <dt><b>impratio :</b> real, "1"</dt>
    <dd>
        This attribute determines the ratio of frictional-to-normal constraint impedance for elliptic friction cones. The setting of solimp determines a single impedance value for all contact dimensions, which is then modulated by this attribute. Settings larger than 1 cause friction forces to be "harder" than normal forces, having the general effect of preventing slip, without increasing the actual friction coefficient. For pyramidal friction cones the situation is more complex because the pyramidal approximation mixes normal and frictional dimensions within each basis vector; but the overall effect of this attribute is qualitatively similar. 
    </dd>

    <dt><b>o_margin :</b> real, "0"</dt>
    <dd>
        This attribute replaces the margin parameter of all active contact pairs when <a href="http://mujoco.org/book/modeling.html#COverride">Contact override</a> is enabled. Otherwise MuJoCo uses the element-specific <span>margin</span> attribute of <a href="http://mujoco.org/book/modeling.html#geom">geom</a> or <a href="http://mujoco.org/book/modeling.html#pair">pair</a> depending on how the contact pair was generated. See also <a href="http://mujoco.org/book/computation.html#Collision">Collision detection</a> in the Computation chapter.
        The related <span>gap</span> parameter does not have a global override.
    </dd>

    <dt><b>o_solref :</b> real(2), "0.02 1"</dt>
    <dd>
        This attribute replaces the <span>solref</span> parameter of all active contact pairs when contact override is enabled. See also <a href="http://mujoco.org/book/modeling.html#CSolver">Solver parameters</a>.
    </dd>

    <dt><b>o_solimp :</b> real(3), "0.8 0.8 0.01"</dt>
    <dd>        
        This attribute replaces the <span>solimp</span> parameter of all active contact pairs when contact override is enabled. See also <a href="http://mujoco.org/book/modeling.html#CSolver">Solver parameters</a>.
    </dd>

    <dt><b>integrator :</b> [Euler, RK4], "Euler"</dt>
    <dd>
        This attribute selects the numerical <a href="http://mujoco.org/book/computation.html#geIntegration">integrator</a> to be used. 
        Currently the available integrators are the semi-implicit Euler method and the fixed-step 4-th order Runge Kutta method.
    </dd>

    <dt><b>collision :</b> [all, predefined, dynamic], "all"</dt>
    <dd>
        This attribute specifies which geom pairs should be checked for collision; recall <a href="http://mujoco.org/book/computation.html#Collision">Collision detection</a> in the Computation chapter. "predefined" means that only the explicitly-defined contact <a href="http://mujoco.org/book/modeling.html#pair">pairs</a> are checked. "dynamic" means that only the contact pairs generated dynamically are checked. "all" means that the contact pairs from both sources are checked.
    </dd>

    <dt><b>impedance :</b> [constant, sigmoid, linear, user], "sigmoid"</dt>
    <dd>
        This attribute selects the spatial profile of the constraint impedance. See <a href="http://mujoco.org/book/modeling.html#CSolver">Solver parameters</a> for a description of built-in impedance profiles. "user" means that the callback <a href="http://mujoco.org/book/reference.html#mjcb_sol_imp">mjcb_sol_imp</a> will be used to compute the constraint impedance at runtime.
    </dd>

    <dt><b>reference :</b> [spring, user], "spring"</dt>
    <dd>
        This attribute controls the computation of the reference acceleration. The default setting corresponds to the virtual spring-damper described in <a href="http://mujoco.org/book/modeling.html#CSolver">Solver parameters</a>. "user" means that the callback <a href="http://mujoco.org/book/reference.html#mjcb_sol_ref">mjcb_sol_ref</a> will be used to compute the reference acceleration at runtime.
    </dd>

    <dt><b>cone :</b> [pyramidal, elliptic], "pyramidal"</dt>
    <dd>
        The type of contact friction cone. Elliptic cones are a better model of the physical reality, but pyramidal cones sometimes make the solver faster and more robust.
    </dd>

    <dt><b>jacobian :</b> [dense, sparse, auto], "auto"</dt>
    <dd>
        The type of constraint Jacobian and matrices computed from it. Auto resolves to dense when the number of degrees of freedom is up to 60, and sparse over 60.
    </dd>

    <dt><b>solver :</b> [PGS, CG, Newton], "Newton"</dt>
    <dd>
        This attribute selects one of the constraint solver <a href="http://mujoco.org/book/computation.html#soAlgorithms">algorithms</a> described in the Computation chapter. Guidelines for solver selection and parameter tuning are available in the <a href="http://mujoco.org/book/modeling.html#CAlgorithms">Algorithms</a> section above.
    </dd>

    <dt><b>iterations :</b> int, "100"</dt>
    <dd>
        Maximum number of iterations of the constraint solver. When the <span>warmstart</span> attribute of <a href="http://mujoco.org/book/modeling.html#option-flag">flag</a> is enabled (which is the default), accurate results are obtained with fewer iterations. Larger and more complex systems with many interacting constraints require more iterations. Note that mjData.solver contains statistics about solver convergence, also shown in the profiler.
    </dd>

    <dt><b>tolerance :</b> real, "1e-8"</dt>
    <dd>
        Tolerance threshold used for early termination of the iterative solver. For PGS, the threshold is applied to the cost improvement between two iterations. For CG and Newton, it is applied to the smaller of the cost improvement and the gradient norm. Set the tolerance to 0 to disable early termination.
    </dd>

    <dt><b>noslip_iterations :</b> int, "0"</dt>
    <dd>
        Maximum number of iterations of the Noslip solver. This is a post-processing step executed after the main solver. It uses a modified PGS method to suppress slip/drift in friction dimensions resulting from the soft-constraint model. The default setting 0 disables this post-processing step.
    </dd>

    <dt><b>noslip_tolerance :</b> real, "1e-6"</dt>
    <dd>
        Tolerance threshold used for early termination of the Noslip solver.
    </dd>

    <dt><b>mpr_iterations :</b> int, "50"</dt>
    <dd>
        Maximum number of iterations of the MPR algorithm used for convex mesh collisions. This rarely needs to be adjusted, except in situations where some geoms have very large aspect ratios.
    </dd>

    <dt><b>mpr_tolerance :</b> real, "1e-6"</dt>
    <dd>
        Tolerance threshold used for early termination of the MPR algorithm.
    </dd>
</dl>


<h3 id="option-flag">option/ <b>flag</b> (?)</h3>
<p>
    This element sets the flags that enable and disable different parts of the simulation pipeline. The actual flags used at runtime are represented as the bits of two integers, namely mjModel.opt.disableflags and mjModel.opt.enableflags, used to disable standard features and enable optional features respectively. The reason for this separation is that setting both integers to 0 restores the default. In the XML we do not make this separation explicit, except for the default attribute values - which are "enable" for flags corresponding to standard features, and "disable" for flags corresponding to optional features. In the documentation below, we explain what happens when the setting is different from its default.
</p>

<dl>
    <dt><b>constraint :</b> [disable, enable], "enable"</dt>
    <dd>
        This flag disables all standard computations related to the constraint solver. As a result, no constraint forces are applied. Note that the next four flags disable the computations related to a specific type of constraint. Both this flag and the type-specific flag must be set to "enable" for a given computation to be performed.
    </dd>

    <dt><b>equality :</b> [disable, enable], "enable"</dt>
    <dd>
        This flag disables all standard computations related to equality constraints.
    </dd>

    <dt><b>frictionloss :</b> [disable, enable], "enable"</dt>
    <dd>
        This flag disables all standard computations related to friction loss constraints.
    </dd>

    <dt><b>limit :</b> [disable, enable], "enable"</dt>
    <dd>
        This flag disables all standard computations related to joint and tendon limit constraints.
    </dd>

    <dt><b>contact :</b> [disable, enable], "enable"</dt>
    <dd>
        This flag disables all standard computations related to contact constraints.
    </dd>

    <dt><b>passive :</b> [disable, enable], "enable"</dt>
    <dd>
        This flag disables the simulation of joint and tendon spring-dampers, fluid dynamics forces, and custom passive forces computed by the <a href="http://mujoco.org/book/reference.html#mjcb_passive">mjcb_passive</a> callback. As a result, no passive forces are applied.
    </dd>

    <dt><b>gravity :</b> [disable, enable], "enable"</dt>
    <dd>
        This flag causes the gravitational acceleration vector in mjOption to be replaced with (0 0 0) at runtime, without changing the value in mjOption. Once the flag is re-enabled, the value in mjOption is used.
    </dd>

    <dt><b>clampctrl :</b> [disable, enable], "enable"</dt>
    <dd>
        This flag disables the clamping of control inputs to all actuators, even if the actuator-specific attributes are set to enable clamping.
    </dd>

    <dt><b>warmstart :</b> [disable, enable], "enable"</dt>
    <dd>
        This flag disables warm-starting of the constraint solver. By default the solver uses the solution (i.e. the constraint force) from the previous time step to initialize the iterative optimization. This feature should be disabled when evaluating the dynamics at a collection of states that do not form a trajectory - in which case warm starts make no sense and are likely to slow down the solver.
    </dd>

    <dt><b>filterparent :</b> [disable, enable], "enable"</dt>
    <dd>
        This flag disables the filtering of contact pairs where the two geoms belong to a parent and child body; recall contact <a href="http://mujoco.org/book/computation.html#coSelection">selection</a> in the Computation chapter.
    </dd>

    <dt><b>actuation :</b> [disable, enable], "enable"</dt>
    <dd>
        This flag disables all standard computations related to actuator forces, including the actuator dynamics. As a result, no actuator forces are applied to the simulation. 
    </dd>

    <dt><b>refsafe :</b> [disable, enable], "enable"</dt>
    <dd>
        This flag enables a safety mechanism that prevents instabilities due to solref[0] being too small compared to the simulation timestep. Recall that solref[0] is the stiffness of the virtual spring-damper used for constraint stabilization. If this setting is enabled, the solver uses max(solref[0], 2*timestep) in place of solref[0] separately for each active constraint.
    </dd>

    <dt><b>override :</b> [disable, enable], "disable"</dt>
    <dd>
        This flag enables to <a href="http://mujoco.org/book/modeling.html#COverride">Contact override</a> mechanism explained above.
    </dd>

    <dt><b>energy :</b> [disable, enable], "disable"</dt>
    <dd>
        This flag enables the computation of kinetic and potential energy, stored in mjData.energy and displayed in the GUI. This feature adds some CPU time but it is usually negligible. Monitoring energy for a system that is supposed to be energy-conserving is one of the best ways to assess the accuracy of a complex simulation.
    </dd>

    <dt><b>fwdinv :</b> [disable, enable], "disable"</dt>
    <dd>
        This flag enables the automatic comparison of forward and inverse dynamics. When enabled, the inverse dynamics is invoked after mj_forward (or internally within mj_step) and the difference in applied forces is recorded in mjData.solver_fwdinv[2]. The first value is the relative norm of the discrepancy in joint space, the next is in constraint space.
    </dd>

    <dt><b>sensornoise :</b> [disable, enable], "disable"</dt>
    <dd>
        This flag enables the simulation of sensor noise. When disabled (which is the default) noise is not added to sensordata, even if the sensors specify non-zero noise amplitudes. When enabled, zero-mean Gaussian noise is added to the underlying deterministic sensor data. Its standard deviation is determined by the noise parameter of each sensor.
    </dd>
</dl>


<h3 id="size"><b>size</b> (*)</h3>
<p>
    This element specifies size parameters that cannot be inferred from the number of elements in the model. Unlike the fields of mjOption which can be modified at runtime, sizes are structural parameters and should not be modified after compilation.
</p>

<dl>
    <dt><b>njmax :</b> int, "-1"</dt>
    <dd>
        This and the next two attributes specify the maximum sizes of the dynamic arrays in mjData, i.e. arrays whose effective length varies at runtime. This attribute specifies the maximum number of scalar constraints (or equivalently, rows of the constraint Jacobian) that can be handled at runtime. If the number of active constraints is about to exceed this maximum (usually because too many contacts become active) the extra constraints are discarded and a warning is generated. The number of active constraints is stored in mjData.nefc. The default setting of -1 instructs the compiler to guess how much space to allocate (using heuristics that can be improved). This default is effectively an undefined state. If the user specifies a positive value, the compiler heuristics are disabled and the specified value is used. Modern computers have sufficient memory to handle very large models (larger than one would normally have the patience to simulate) so tuning this setting aggressively is not necessary. When size-related warnings or errors are generated, simply increase the value of the corresponding attribute.
    </dd>

    <dt><b>nconmax :</b> int, "-1"</dt>
    <dd>
        This attribute specifies the maximum number of contacts (both frictional and frictionless) that can be handled at runtime. If the number of active contacts is about to exceed this value, the extra contacts are discarded and a warning is generated. The actual number of contacts is stored in mjData.ncon. If this value is negative, the compiler will use a heuristic to guess an appropriate number.
    </dd>

    <dt><b>nstack :</b> int, "-1"</dt>
    <dd>
        This attribute specifies the size of the pre-allocated stack in mjData, in units of sizeof(mjtNum) which is currently defined as double; thus the size in bytes is 8 times larger. The custom stack is used by all MuJoCo functions that need dynamically allocated memory. We do not use heap memory allocation at runtime, so as to speed up processing as well as avoid heap fragmentation. Note that the internal allocator keeps track of how much stack space has ever been utilized, in the field mjData.maxstackuse of mjData. If the stack size is exceeded at runtime, MuJoCo will generate an error. If this value is negative, the compiler will use a heuristic to guess an appropriate number.
    </dd>

    <dt><b>nuserdata :</b> int, "0"</dt>
    <dd>
        The size of the field mjData.userdata of mjData. This field should be used to store custom dynamic variables. See also <a href="http://mujoco.org/book/modeling.html#CUser">User parameters</a>.
    </dd>

    <dt><b>nkey :</b> int, "0"</dt>
    <dd>
        The number of key frames allocated in mjModel is the larger of this value and the number of <a href="http://mujoco.org/book/modeling.html#key">key</a> elements below. Note that the interactive simulator has the ability to take snapshots of the system state and save them as key frames.
    </dd>

    <dt><b>nuser_body :</b> int, "0"</dt>
    <dd>
        The number of custom user parameters added to the definition of each body. See also <a href="http://mujoco.org/book/modeling.html#CUser">User parameters</a>. The parameter values are set via the <span>user</span> attribute of the <a href="http://mujoco.org/book/modeling.html#body">body</a> element. These values are not accessed by MuJoCo. They can be used to define element properties needed in user callbacks and other custom code.
    </dd>

    <dt><b>nuser_jnt :</b> int, "0"</dt>
    <dd>
        The number of custom user parameters added to the definition of each <a href="http://mujoco.org/book/modeling.html#joint">joint</a>.
    </dd>

    <dt><b>nuser_geom :</b> int, "0"</dt>
    <dd>
        The number of custom user parameters added to the definition of each <a href="http://mujoco.org/book/modeling.html#geom">geom</a>.
    </dd>

    <dt><b>nuser_site" :</b> int, "0"</dt>
    <dd>
        The number of custom user parameters added to the definition of each <a href="http://mujoco.org/book/modeling.html#site">site</a>.
    </dd>

    <dt><b>nuser_cam" :</b> int, "0"</dt>
    <dd>
        The number of custom user parameters added to the definition of each <a href="http://mujoco.org/book/modeling.html#camera">camera</a>.
    </dd>

    <dt><b>nuser_tendon :</b> int, "0"</dt>
    <dd>
        The number of custom user parameters added to the definition of each <a href="http://mujoco.org/book/modeling.html#tendon">tendon</a>.
    </dd>

    <dt><b>nuser_actuator :</b> int, "0"</dt>
    <dd>
        The number of custom user parameters added to the definition of each <a href="http://mujoco.org/book/modeling.html#actuator">actuator</a>.
    </dd>

    <dt><b>nuser_sensor :</b> int, "0"</dt>
    <dd>
        The number of custom user parameters added to the definition of each <a href="http://mujoco.org/book/modeling.html#sensor">sensor</a>.
    </dd>
</dl>


<h3 id="visual"><b>visual</b> (*)</h3>
<p>
    This element is is one-to-one correspondence with the low level structure mjVisual contained in the field mjModel.vis of mjModel. The settings here affect the visualizer, or more precisely the abstract phase of visualization which yields a list of geometric entities for subsequent rendering. The settings here are global, in contrast with the element-specific visual settings. The global and element-specific settings refer to non-overlapping properties. Some of the global settings affect properties such as triangulation of geometric primitives that cannot be set per element. Other global settings affect the properties of decorative objects, i.e. objects such as contact points and force arrows which do not correspond to model elements. The visual settings are grouped semantically into several subsections.
    <br><br>

    This element is a good candidate for the <a href="http://mujoco.org/book/modeling.html#CInclude">file include</a> mechanism. One can create an XML file with coordinated visual settings corresponding to a "theme", and then include this file in multiple models.
</p>


<h3 id="global">visual/ <b>global</b> (?)</h3>
<p>
    While all settings in mjVisual are global, the settings here could not be fit into any of the other subsections. So this is effectively a miscellaneous subsection.
</p>

<dl>
    <dt><b>fovy :</b> real, "45"</dt>
    <dd>
        This attribute specifies the vertical field of view of the free camera, i.e. the camera that is always available in the visualizer even if no cameras are explicitly defined in the model. It is always expressed in degrees, regardless of the setting of the <span>angle</span> attribute of <a href="http://mujoco.org/book/modeling.html#compiler">compiler</a>, and is also represented in the low level model in degrees. This is because we pass it to OpenGL which uses degrees. The same convention applies to the <span>fovy</span> attribute of the <a href="http://mujoco.org/book/modeling.html#camera">camera</a> element below.
    </dd>

    <dt><b>ipd :</b> real, "0.068"</dt>
    <dd>
        This attribute specifies the inter-pupilary distance of the free camera. It only affects the rendering in stereoscopic mode. The left and right viewpoints are offset by half of this value in the corresponding direction.
    </dd>

    <dt><b>linewidth :</b> real, "1"</dt>
    <dd>
        This attribute specifies the line-width in the sense of OpenGL. It affects the rendering in wire-frame mode.
    </dd>

    <dt><b>glow :</b> real, "0.3"</dt>
    <dd>
        The value of this attribute is added to the emission coefficient of all geoms attached to the selected body. As a result, the selected body appears to glow.
    </dd>

    <dt><b>offwidth :</b> int, "640"</dt>
    <dd>
        This and the next attribute specify the size in pixels of the off-screen OpenGL rendering buffer. This attribute specifies the width of the buffer. The size of this buffer can also be adjusted at runtime, but it is usually more convenient to set it in the XML.
    </dd>

    <dt><b>offheight :</b> int, "480"</dt>
    <dd>
        This attribute specifies the height in pixels of the OpenGL off-screen rendering buffer.
    </dd>
</dl>


<h3 id="quality">visual/ <b>quality</b> (?)</h3>
<p>
    This element specifies settings that affect the quality of the rendering. Larger values result in higher quality but possibly slower speed. Note that both HAPTIX and Pro display the frames per second (FPS). The target FPS is 60 Hz; if the number shown in the visualizer is substantially lower, this means that the GPU is over-loaded and the visualization should somehow be simplified.
</p>

<dl>
    <dt><b>shadowsize :</b> int, "1024"</dt>
    <dd>
        This attribute specifies the size of the square texture used for shadow mapping. Higher values result is smoother shadows. The size of the area over which a <a href="http://mujoco.org/book/modeling.html#light">light</a> can cast shadows also affects smoothness, so these settings should be adjusted jointly. The default here is somewhat conservative. Most modern GPUs are able to handle significantly larger textures without slowing down. The OSX version of MuJoCo does not presently render shadows, because Apple does not support the necessary compatibility contexts. When MuJoCo detects that shadow mapping (or any other advanced feature) is not supported by the video driver, it automatically disables that feature.
    </dd>

    <dt><b>offsamples :</b> int, "4"</dt>
    <dd>
        This attribute specifies the number of multi-samples for offscreen rendering. Larger values produce better anti-aliasing but can slow down the GPU. Set this to 0 to disable multi-sampling. Note that this attribute only affects offscreen rendering. For regular window rendering, multi-sampling is specified in an OS-dependent way when the OpenGL context for the window is first created, and cannot be changed from within MuJoCo.
    </dd>

    <dt><b>numslices :</b> int, "28"</dt>
    <dd>
        This and the next three attributes specify the density of internally-generated meshes for geometric primitives. Such meshes are only used for rendering, while the collision detector works with the underlying analytic surfaces. This value is passed to the various visualizer functions as the "slices" parameter as used in GLU. It specifies the number of subdivisions around the Z-axis, similar to lines of longitude.
    </dd>

    <dt><b>numstacks :</b> int, "16"</dt>
    <dd>
        This value of this attribute is passed to the various visualization functions as the "stacks" parameter as used in GLU. It specifies the number of subdivisions along the Z-axis, similar to lines of latitude.
    </dd>

    <dt><b>numarrows :</b> int, "10"</dt>
    <dd>
        This attribute specifies the number of arrows in a circular rendering of 3D torque (currently disabled).
    </dd>

    <dt><b>numquads :</b> int, "4"</dt>
    <dd>
        This attribute specifies the number of rectangles for rendering box faces, automatically-generated planes (as opposed to geom planes which have an element-specific attribute with the same function), and sides of height fields. Even though a geometrically correct rendering can be obtained by setting this value to 1, illumination works better for larger values because we use per-vertex illumination (as opposed to per-fragment).
    </dd>
</dl>


<h3 id="headlight">visual/ <b>headlight</b> (?)</h3>
<p>
    This element is used to adjust the properties of the headlight. There is always a built-in headlight, in addition to any lights explicitly defined in the model. The headlight is a directional light centered at the current camera and pointed in the direction in which the camera is looking. It does not cast shadows (which would be invisible anyway). Note that lights are additive, so if explicit lights are defined in the model, the intensity of the headlight would normally need to be reduced.
</p>

<dl>
    <dt><b>ambient :</b> real(3), "0.1 0.1 0.1"</dt>
    <dd>
        The ambient component of the headlight, in the sense of OpenGL. The alpha component here and in the next two attributes is set to 1 and cannot be adjusted.
    </dd>

    <dt><b>diffuse :</b> real(3), "0.4 0.4 0.4"</dt>
    <dd>
        The diffuse component of the headlight, in the sense of OpenGL. 
    </dd>

    <dt><b>specular :</b> real(3), "0.5 0.5 0.5"</dt>
    <dd>
        The specular component of the headlight, in the sense of OpenGL. 
    </dd>

    <dt><b>active :</b> int, "1"</dt>
    <dd>
        This attribute enables and disables the headlight. A value of 0 means disabled, any other value means enabled.
    </dd>
</dl>


<h3 id="map">visual/ <b>map</b> (?)</h3>
<p>
    This element is used to specify scaling quantities that affect both the visualization and built-in mouse perturbations. Unlike the scaling quantities in the next element which are specific to spatial extent, the quantities here are miscellaneous.
</p>

<dl>
    <dt><b>stiffness :</b> real, "100"</dt>
    <dd>
        This attribute controls the strength of mouse perturbations. The internal perturbation mechanism simulates a mass-spring-damper with critical damping, unit mass, and stiffness given here. Larger values mean that a larger force will be applied for the same displacement between the selected body and the mouse-controlled target.
    </dd>

    <dt><b>stiffnessrot :</b> real, "500"</dt>
    <dd>
        Same as above but applies to rotational perturbations rather than translational perturbations. Empirically, the rotational stiffness needs to be larger in order for rotational mouse perturbations to have an effect.
    </dd>

    <dt><b>force :</b> real, "0.005"</dt>
    <dd>
        This attributes controls the visualization of both contact forces and perturbation forces. The length of the rendered force vector equals the force magnitude multiplied by the value of this attribute and divided by the mean body mass for the model (see <a href="http://mujoco.org/book/modeling.html#statistic">statistic</a> element below).
    </dd>

    <dt><b>torque :</b> real, "0.1"</dt>
    <dd>
        Same as above, but controls the rendering of contact torque and perturbation torque rather than force (currently disabled).
    </dd>

    <dt><b>alpha :</b> real, "0.3"</dt>
    <dd>
        When transparency is turned on in the visualizer, the geoms attached to all moving bodies are made more transparent. This is done by multiplying the geom-specific alpha values by this value.
    </dd>

    <dt><b>fogstart :</b> real, "3"</dt>
    <dd>
        The visualizer can simulate linear fog, in the sense of OpenGL. The start position of the fog is the model extent (see <a href="http://mujoco.org/book/modeling.html#statistic">statistic</a> element below) multiplied by the value of this attribute.
    </dd>

    <dt><b>fogend :</b> real, "10"</dt>
    <dd>
        The end position of the fog is the model extent multiplied by the value of this attribute.
    </dd>

    <dt><b>znear :</b> real, "0.2"</dt>
    <dd>
        This and the next attribute determine the clipping planes of the OpenGL projection. The near clipping plane is particularly important: setting it too close causes (often severe) loss of resolution in the depth buffer, while setting it too far causes objects of interest to be clipped, making it impossible to zoom in. The distance to the near clipping plane is the model extent multiplied by the value of this attribute.
    </dd>

    <dt><b>zfar :</b> real, "50"</dt>
    <dd>
        The distance to the far clipping plane is the model extent multiplied by the value of this attribute.
    </dd>

    <dt><b>shadowclip :</b> real, "1"</dt>
    <dd>
        As mentioned above, shadow quality depends on the size of the shadow texture as well as the area where a given light can cast shadows. For directional lights, the area would be infinite unless we limited it somehow. This attribute specifies the limits, as +/- the model extent multiplied by the present value. These limits define a square in the plane orthogonal to the light direction. If a shadow crosses the boundary of this virtual square, it will disappear abruptly, revealing the edges of the square.
    </dd>

    <dt><b>shadowscale :</b> real, "0.6"</dt>
    <dd>
        This attribute plays a similar role as the previous one, but applies to spotlights rather than directional lights. Spotlights have a cutoff angle, limited internally to 80 deg. However this angle is often too large to obtain good quality shadows, and it is necessary to limit the shadow to a smaller cone. The angle of the cone in which shadows can be cast is the light <span>cutoff</span> multiplied by the present value.
    </dd>
</dl>


<h3 id="scale">visual/ <b>scale</b> (?)</h3>
<p>
    The settings in this element control the spatial extent of various decorative objects. In all cases, the rendered size equals the mean body size (see <a href="http://mujoco.org/book/modeling.html#statistic">statistic</a> element below) multiplied by the value of an attribute documented below.
</p>

<dl>
    <dt><b>forcewidth :</b> real, "0.1"</dt>
    <dd>
        The radius of the arrows used to render contact forces and perturbation forces.
    </dd>

    <dt><b>contactwidth :</b> real, "0.3"</dt>
    <dd>
        The radius of the cylinders used to render contact points. The normal direction of the cylinder is aligned with the contact normal. Making the cylinder short and wide results in a "pancake" representation of the tangent plane.
    </dd>

    <dt><b>contactheight :</b> real, "0.1"</dt>
    <dd>
        The height of the cylinders used to render contact points.
    </dd>

    <dt><b>connect :</b> real, "0.2"</dt>
    <dd>
        The radius of the capsules used to connect bodies and joints, resulting in an automatically generated skeleton.
    </dd>

    <dt><b>com :</b> real, "0.4"</dt>
    <dd>
        The radius of the spheres used to render the centers of mass of kinematic sub-trees.
    </dd>

    <dt><b>camera :</b> real, "0.3"</dt>
    <dd>
        The size of the decorative object used to represent model cameras in the rendering.
    </dd>

    <dt><b>light :</b> real, "0.3"</dt>
    <dd>
        The size of the decorative object used to represent model lights in the rendering.
    </dd>

    <dt><b>selectpoint :</b> real, "0.2"</dt>
    <dd>
        The radius of the sphere used to render the selection point (i.e. the point where the user left-double-clicked to select a body). Note that the local and global coordinates of this point can be printed in the 3D view by activating the corresponding rendering flags. In this way, the coordinates of points of interest can be found.
    </dd>

    <dt><b>jointlength :</b> real, "1.0"</dt>
    <dd>
        The length of the arrows used to render joint axes.
    </dd>

    <dt><b>jointwidth :</b> real, "0.1"</dt>
    <dd>
        The radius of the arrows used to render joint axes.
    </dd>

    <dt><b>actuatorlength :</b> real, "0.7"</dt>
    <dd>
        The length of the arrows used to render actuators acting on scalar joints only.
    </dd>

    <dt><b>actuatorwidth :</b> real, "0.2"</dt>
    <dd>
        The radius of the arrows used to render actuators acting on scalar joints only.
    </dd>

    <dt><b>framelength :</b> real, "1.0"</dt>
    <dd>
        The length of the cylinders used to render coordinate frames. The world frame is automatically scaled relative to this setting.
    </dd>

    <dt><b>framewidth :</b> real, "0.1"</dt>
    <dd>
        The radius of the cylinders used to render coordinate frames.
    </dd>

    <dt><b>constraint :</b> real, "0.1"</dt>
    <dd>
        The radius of the capsules used to render violations in spatial constraints.
    </dd>

    <dt><b>slidercrank :</b> real, "0.2"</dt>
    <dd>
        The radius of the capsules used to render slider-crank mechanisms. The second part of the mechanism is automatically scaled relative to this setting.
    </dd>
</dl>


<h3 id="rgba">visual/ <b>rgba</b> (?)</h3>
<p>
    The settings in this element control the color and transparency (rgba) of various decorative objects. We will call this combined attribute "color" to simplify terminology below. All values should be in the range [0 1]. An alpha value of 0 disables the rendering of the corresponding object.
</p>

<dl>
    <dt><b>fog :</b> real(4), "0 0 0 1"</dt>
    <dd>
        When fog is enabled, the color of all pixels fades towards the color specified here. The spatial extent of the fading is controlled by the <span>fogstart</span> and <span>fogend</span> attributes of the <a href="http://mujoco.org/book/modeling.html#map">map</a> element above.
    </dd>

    <dt><b>force :</b> real(4), "1 0.5 0.5 1"</dt>
    <dd>
        Color of the arrows used to render perturbation forces.
    </dd>

    <dt><b>inertia :</b> real(4), "0.8 0.2 0.2 0.6"</dt>
    <dd>
        Color of the boxes used to render equivalent body inertias. This is the only rgba setting that has transparency by default, because it is usually desirable to see the geoms inside the inertia box.
    </dd>

    <dt><b>joint :</b> real(4), "0.2 0.6 0.8 1"</dt>
    <dd>
        Color of the arrows used to render joint axes.
    </dd>

    <dt><b>actuator :</b> real(4), "0.9 0.4 0.4 1"</dt>
    <dd>
        Color of the arrows used to render actuators acting on scalar joints.
    </dd>

    <dt><b>com :</b> real(4), "0.9 0.9 0.9 1"</dt>
    <dd>
        Color of the spheres used to render sub-tree centers of mass.
    </dd>

    <dt><b>camera :</b> real(4), "0.6 0.9 0.6 1"</dt>
    <dd>
        Color of the decorative object used to represent model cameras in the rendering.
    </dd>

    <dt><b>light :</b> real(4), "0.6 0.6 0.9 1"</dt>
    <dd>
        Color of the decorative object used to represent model lights in the rendering.
    </dd>

    <dt><b>selectpoint :</b> real(4), "0.9 0.9 0.1 1"</dt>
    <dd>
        Color of the sphere used to render the selection point.
    </dd>

    <dt><b>connect :</b> real(4), "0.2 0.2 0.8 1"</dt>
    <dd>
        Color of the capsules used to connect bodies and joints, resulting in an automatically generated skeleton.
    </dd>

    <dt><b>contactpoint :</b> real(4), "0.9 0.6 0.2 1"</dt>
    <dd>
        Color of the cylinders used to render contact points.
    </dd>

    <dt><b>contactforce :</b> real(4), "0.7 0.9 0.9 1"</dt>
    <dd>
        Color of the arrows used to render contact forces. When splitting of contact forces into normal and tangential components is enabled, this color is used to render the normal components.
    </dd>

    <dt><b>contactfriction :</b> real(4), "0.9 0.8 0.4 1"</dt>
    <dd>
        Color of the arrows used to render contact tangential forces, only when splitting is enabled.
    </dd>

    <dt><b>contacttorque :</b> real(4), "0.9 0.7 0.9 1"</dt>
    <dd>
        Color of the arrows used to render contact torques (currently disabled).
    </dd>

    <dt><b>constraint :</b> real(4), "0.9 0 0 1"</dt>
    <dd>
        Color of the capsules corresponding to spatial constraint violations.
    </dd>

    <dt><b>slidercrank :</b> real(4), "0.5 0.3 0.8 1"</dt>
    <dd>
        Color of slider-crank mechanisms.
    </dd>

    <dt><b>crankbroken :</b> real(4), "0.9 0 0 1"</dt>
    <dd>
        Color used to render the crank of slide-crank mechanisms, in model configurations where the specified rod length cannot be maintained, i.e. it is "broken".
    </dd>
</dl>



<h3 id="statistic"><b>statistic</b> (*)</h3>
<p>
    This element is used to override model statistics computed by the compiler. These statistics are not only informational but are also used to scale various components of the rendering and perturbation. We provide an override mechanism in the XML because it is sometimes easier to adjust a small number of model statistics than a larger number of visual parameters.
</p>

<dl>
    <dt><b>meanmass :</b> real, optional</dt>
    <dd>
        If this attribute is specified, it replaces the value of mjModel.stat.meanmass computed by the compiler. The computed value is the average body mass, not counting the massless world body. At runtime this value scales the perturbation force.
    </dd>

    <dt><b>meaninertia :</b> real, optional</dt>
    <dd>
        If this attribute is specified, it replaces the value of mjModel.stat.meaninertia computed by the compiler. The computed value is the average diagonal element of the joint-space inertia matrix when the model is in qpos0. At runtime this value scales the solver cost and gradient used for early termination.
    </dd>

    <dt><b>meansize :</b> real, optional</dt>
    <dd>
        If this attribute is specified, it replaces the value of mjModel.stat.meansize computed by the compiler. The computed value is heuristic representing the average body radius. This is not easily determined because bodies may not have geoms with spatial properties. The heuristic is based on the geoms sizes when present, the distances between joints when present, and the sizes of the body equivalent inertia boxes. At runtime this value is multiplied by the attributes of the <a href="http://mujoco.org/book/modeling.html#scale">scale</a> element above.
    </dd>
    
    <dt><b>extent :</b> real, optional</dt>
    <dd>
        If this attribute is specified, it replaces the value of mjModel.stat.extent computed by the compiler. The computed value is half the side of the bounding box of the model in the initial configuration. At runtime this value is multiplied by some of the attributes of the <a href="http://mujoco.org/book/modeling.html#map">map</a> element above.
    </dd>
    
    <dt><b>center :</b> real(3), optional</dt>
    <dd>
        If this attribute is specified, it replaces the value of mjModel.stat.center computed by the compiler. The computed value is the center of the bounding box of the entire model in the initial configuration. This 3D vector is used to center the view of the free camera when the model is first loaded.
    </dd>
</dl>


<h3 id="default"><b>default</b> (R)</h3>
<p>
    This element is used to create a new defaults class; see <a href="http://mujoco.org/book/modeling.html#CDefault">Default settings</a> above. Defaults classes can be nested, inheriting all attribute values from their parent. The top-level defaults class is always defined; it is called "main" if omitted.

    </p><dl>
    <dt><b>class :</b> string, required (except at the top level)</dt>
    <dd>
         The name of the defaults class. It must be unique among all defaults classes. This name is used to make the class active when creating an actual model element.
    </dd>
    </dl>
<p></p>


<h3 id="default-mesh">default/ <b>mesh</b> (?)</h3>
<p>
    This element sets the attributes of the dummy <a href="http://mujoco.org/book/modeling.html#mesh">mesh</a> element of the defaults class.
    <br>
    The only mesh attribute available here is: <span><b>scale</b></span>.
</p>


<h3 id="default-material">default/ <b>material</b> (?)</h3>
<p>
    This element sets the attributes of the dummy <a href="http://mujoco.org/book/modeling.html#material">material</a> element of the defaults class. 
    <br>
    All material attributes are available here except:
    <span>name, class</span>.
</p>


<h3 id="default-joint">default/ <b>joint</b> (?)</h3>
<p>
    This element sets the attributes of the dummy <a href="http://mujoco.org/book/modeling.html#joint">joint</a> element of the defaults class.
    <br>
    All joint attributes are available here except:
    <span>name, class</span>.
</p>


<h3 id="default-geom">default/ <b>geom</b> (?)</h3>
<p>
    This element sets the attributes of the dummy <a href="http://mujoco.org/book/modeling.html#geom">geom</a> element of the defaults class.
    <br>
    All geom attributes are available here except:
    <span>name, class</span>.
</p>


<h3 id="default-site">default/ <b>site</b> (?)</h3>
<p>
    This element sets the attributes of the dummy <a href="http://mujoco.org/book/modeling.html#site">site</a> element of the defaults class.
    <br>
    All site attributes are available here except:
    <span>name, class</span>.
</p>


<h3 id="default-camera">default/ <b>camera</b> (?)</h3>
<p>
    This element sets the attributes of the dummy <a href="http://mujoco.org/book/modeling.html#camera">camera</a> element of the defaults class. 
    <br>
    All camera attributes are available here except:
    <span>name, class</span>.
</p>


<h3 id="default-light">default/ <b>light</b> (?)</h3>
<p>
    This element sets the attributes of the dummy <a href="http://mujoco.org/book/modeling.html#light">light</a> element of the defaults class. 
    <br>
    All light attributes are available here except:
    <span>name, class</span>.
</p>


<h3 id="default-pair">default/ <b>pair</b> (?)</h3>
<p>
    This element sets the attributes of the dummy <a href="http://mujoco.org/book/modeling.html#pair">pair</a> element of the defaults class.
    <br>
    All pair attributes are available here except:
    <span>class, geom1, geom2</span>.
</p>


<h3 id="default-equality">default/ <b>equality</b> (?)</h3>
<p>
    This element sets the attributes of the dummy <a href="http://mujoco.org/book/modeling.html#equality">equality</a> element of the defaults class. The actual equality constraints have types depending on the sub-element used to define them. However here we are setting attributes common to all equality constraint types, which is why we do not make a distinction between types.
    <br>
    The equality sub-element attributes available here are:
    <span><b>active, solref, solimp</b></span>.
</p>


<h3 id="default-tendon">default/ <b>tendon</b> (?)</h3>
<p>
    This element sets the attributes of the dummy <a href="http://mujoco.org/book/modeling.html#tendon">tendon</a> element of the defaults class.
    Similar to equality constraints, the actual tendons have types, but here we are setting attributes common to all types.
    <br>
    All tendon sub-element attributes are available here except:
    <span>name, class</span>.
</p>


<h3 id="default-general">default/ <b>general</b> (?)</h3>
<p>
    This element sets the attributes of the dummy <a href="http://mujoco.org/book/modeling.html#general">general</a> element of the defaults class.
    <br>
    All general attributes are available here except:
    <span>name, class, joint, jointinparent, site, tendon, slidersite, cranksite</span>.
</p>


<h3 id="default-motor">default/ <b>motor</b> (?)</h3>
<p>
    This and the next three elements set the attributes of the <a href="http://mujoco.org/book/modeling.html#general">general</a> element using <a href="http://mujoco.org/book/modeling.html#CActuator">Actuator shortcuts</a>. It does not make sense to use more than one such shortcut in the same defaults class, because they set the same underlying attributes, replacing any previous settings. 
    <br>
    All <a href="http://mujoco.org/book/modeling.html#motor">motor</a> attributes are available here except:
    <span>name, class, joint, jointinparent, site, tendon, slidersite, cranksite</span>.
</p>


<h3 id="default-position">default/ <b>position</b> (?)</h3>
<p>
    All <a href="http://mujoco.org/book/modeling.html#position">position</a> attributes are available here except:
    <span>name, class, joint, jointinparent, site, tendon, slidersite, cranksite</span>.
</p>


<h3 id="default-velocity">default/ <b>velocity</b> (?)</h3>
<p>
    All <a href="http://mujoco.org/book/modeling.html#velocity">velocity</a> attributes are available here except:
    <span>name, class, joint, jointinparent, site, tendon, slidersite, cranksite</span>.
</p>


<h3 id="default-cylinder">default/ <b>cylinder</b> (?)</h3>
<p>
    All <a href="http://mujoco.org/book/modeling.html#cylinder">cylinder</a> attributes are available here except:
    <span>name, class, joint, jointinparent, site, tendon, slidersite, cranksite</span>.
</p>


<h3 id="default-muscle">default/ <b>muscle</b> (?)</h3>
<p>
    All <a href="http://mujoco.org/book/modeling.html#muscle">muscle</a> attributes are available here except:
    <span>name, class, joint, jointinparent, site, tendon, slidersite, cranksite</span>.
</p>



<h3 id="custom"><b>custom</b> (*)</h3>
<p>
    This is a grouping element for custom numeric and text elements. It does not have attributes.
</p>


<h3 id="numeric">custom/ <b>numeric</b> (*)</h3>
<p>
    This element creates a custom numeric array in mjModel.
</p>

<dl>
    <dt><b>name :</b> string, required</dt>
    <dd>
        The name of the array. This attribute is required because the only way to find a custom element of interest at runtime is through its name.
    </dd>

    <dt><b>size :</b> int, optional</dt>
    <dd>
        If specified this attribute sets the size of the data array, in doubles. If this attribute is not specified, the size will be inferred from the actual data array below.
    </dd>

    <dt><b>data :</b> real(size), "0 0 ..."</dt>
    <dd>
        Numeric data to be copied into mjModel. If <span>size</span> is specified, the length of the array given here cannot exceed the specified size. If the length of the array is smaller, the missing components are set to 0. Note that custom arrays can be created for storing information at runtime - which is why data initialization is optional. It becomes required only when the array size is omitted.
    </dd>
</dl>



<h3 id="text">custom/ <b>text</b> (*)</h3>
<p>
    This element creates a custom text field in mjModel. It could be used to store keyword commands for user callbacks and other custom computations.
</p>

<dl>
    <dt><b>name :</b> string, required </dt>
    <dd>
        Name of the custom text field.
    </dd>

    <dt><b>data :</b> string, required </dt>
    <dd>
        Custom text to be copied into mjModel.
    </dd>
</dl>


<h3 id="tuple">custom/ <b>tuple</b> (*)</h3>
<p>
    This element creates a custom tuple, which is a list of MuJoCo objects. The list is created by referencing the desired objects by name.
</p>

<dl>
    <dt><b>name :</b> string, required </dt>
    <dd>
        Name of the custom tuple.
    </dd>
</dl>


<h3 id="tupleelement">custom/tuple/ <b>element</b> (*)</h3>
<p>
    This adds an element to the tuple.
</p>

<dl>
    <dt><b>objtype :</b> [body, joint, geom, site, camera, light, mesh, hfield, texture, material, equality, tendon, actuator, sensor, numeric, text, tuple], required </dt>
    <dd>
        Type of the object being added.
    </dd>

    <dt><b>objname :</b> string, required </dt>
    <dd>
        Name of the object being added. The type and name must reference a named MuJoCo element defined somewhere in the model. Tuples can also be referenced (including self-references).
    </dd>

    <dt><b>prm :</b> real, "0" </dt>
    <dd>
        Real-valued parameter associated with this element of the tuple. Its use is up to the user.
    </dd>
</dl>



<h3 id="asset"><b>asset</b> (*)</h3>
<p>
    This is a grouping element for defining assets. It does not have attributes. Assets are created in the model so that they can be referenced from other model elements; recall the discussion of <a href="http://mujoco.org/book/index.html#Assets">Assets</a> in the Overview chapter.
</p>


<h3 id="texture">asset/ <b>texture</b> (*)</h3>
<p>
    This element creates a texture asset, which is then referenced from a <a href="http://mujoco.org/book/modeling.html#material">material</a> asset, which is finally referenced from a model element that needs to be textured. MuJoCo provides access to the texture mapping mechanism in OpenGL. Texture coordinates are generated automatically in GL_OBJECT_PLANE mode, using either 2D or cube mapping. MIP maps are always enabled in GL_LINEAR_MIPMAP_LINEAR mode. The texture color is combined with the object color in GL_MODULATE mode. The texture data can be loaded from PNG files, with provisions for loading cube and skybox textures. Alternatively the data can be generated by the compiler as a procedural texture. Because different texture types require different parameters, only a subset of the attributes below are used for any given texture.
</p>

<dl>
    <dt><b>name :</b> string, optional</dt>
    <dd>
        As with all other assets, a texture must have a name in order to be referenced. However if the texture is loaded from a single file with the <span>file</span> attribute, the explicit name can be omitted and the file name (without the path and extension) becomes the texture name. If the name after parsing is empty and the texture type is not "skybox", the compiler will generate an error.
    </dd>

    <dt><b>type :</b> [2d, cube, skybox], "cube"</dt>
    <dd>
        This attribute determines how the texture is represented and mapped to objects. It also determines which of the remaining attributes are relevant. The keywords have the following meaning:
        <br><br>

        The <b>cube</b> type is the most common. It has the effect of shrink-wrapping a texture cube over an object. Apart from the adjustment provided by the <span>texuniform</span> attribute of <a href="http://mujoco.org/book/modeling.html#material">material</a>, the process is automatic. Internally the GPU constructs a ray from the center of the object to each pixel (or rather fragment), finds the intersection of this ray with the cube surface (the cube and the object have the same center), and uses the corresponding texture color. The six square images defining the cube can be the same or different; if they are the same, only one copy is stored in mjModel. There are four mechanisms for specifying the texture data: 

        <ol>
            <li>
                Single PNG file (specified with the <span>file</span> attribute) containing a square image which is repeated on each side of the cube. This is the most common approach. If for example the goal is to create the appearance of wood, repeating the same image on all sides is sufficient.
            </li>
            <li>
                Single PNG file containing a composite image from which the six squares are extracted by the compiler. The layout of the composite image is determined by the <span>gridsize</span> and <span>gridlayout</span> attributes.
            </li>
            <li>
                Six separate PNG files specified with the attributes <span>fileright</span>, <span>fileleft</span> etc, each containing one square image.
            </li>
            <li>
                Procedural texture generated internally. The type of procedural texture is determined by the <span>builtin</span> attribute. The texture data also depends on a number of parameters documented below.
            </li>
        </ol>

        The <b>skybox</b> type is very similar to cube mapping, and in fact the texture data is specified in exactly the same way. The only difference is that the visualizer uses the first such texture defined in the model to render a skybox. This is a large box centered at the camera and always moving with it, with size determined automatically from the far clipping plane. The idea is that images on the skybox appear stationary, as if they are infinitely far away. If such a texture is referenced from a material applied to a regular object, the effect is equivalent to a cube map. Note however that the images suitable for skyboxes are rarely suitable for texturing objects.
        <br><br>

        The <b>2d</b> type may be the most familiar to users, however it is only suitable for planes and height fields. This is because the texture coordinate generator is trying to map a 2D image to 3D space, and as a result there are entire curves on the object surface that correspond to the same texture pixel. For a box geom for example, the two faces whose normals are aligned with the Z axis of the local frame appear normal, while the other four faces appear stretched. For planes this is not an issue because the plane is always normal to the local Z axis. For height fields the sides enclosing the terrain map appear stretched, but in that case the effect is actually desirable. 2d textures can be rectangular, unlike the sides of cube textures which must be square. The scaling can be controlled with the <span>texrepeat</span> attribute of <a href="http://mujoco.org/book/modeling.html#material">material</a>. The data can be loaded from a single PNG file or created procedurally.
    </dd>

    <dt><b>file :</b> string, optional </dt>
    <dd>
        If this attribute is specified, and the <span>builtin</span> attribute below is set to "none", the texture data is loaded from a single PNG file. See the <span>texturedir</span> attribute of <a href="http://mujoco.org/book/modeling.html#compiler">compiler</a> regarding the file path.
    </dd>

    <dt><b>gridsize :</b> int(2), "1 1"</dt>
    <dd>
        When a cube or skybox texture is loaded from a single PNG file, this attribute and the next specify how the six square sides of the texture cube are obtained from the single image. The default setting "1 1" means that the same image is repeated on all sides of the cube. Otherwise the image is interpreted as a grid from which the six sides are extracted. The two integers here correspond to the number of rows and columns in the grid. Each integer must be positive and the product of the two cannot exceed 12. The number of rows and columns in the image must be integer multiples of the number of rows and columns in the grid, and these two multiples must be equal, so that the extracted images are square.
    </dd>

    <dt><b>gridlayout :</b> string, "............"</dt>
    <dd>
        When a cube or skybox texture is loaded from a single PNG file, and the grid size is different from "1 1", this attribute specifies which grid cells are used and which side of the cube they correspond to. There are many skybox textures available online as composite images, but they do not use the same convention, which is why we have designed a flexible mechanism for decoding them. The string specified here must be composed of characters from the set {'.', 'R', 'L', 'U', 'D', 'F', 'B'}. The number of characters must equal the product of the two grid sizes. The grid is scanned in row-major order. The '.' character denotes an unused cell. The other characters are the first letters of Right, Left, Up, Down, Front, Back; see below for coordinate frame description. If the symbol for a given side appears more than once, the last definition is used. If a given side is omitted, it is filled with the color specified by the <span>rgb1</span> attribute. For example, the desert landscape below can be loaded as a skybox or a cube map using <span>gridsize</span> = "3 4" and <span>gridlayout</span> = ".U..LFRB.D.." The full-resulotion image file without the markings can be downloaded <a href="http://mujoco.org/book/file/desert.png">here</a>.
        <br>
        <img src="./modeling_files/skybox.png" width="250">
    </dd>

    <dt><b>fileright, fileleft, fileup, filedown, filefront, fileback :</b> string, optional</dt>
    <dd>
        These attributes are used to load the six sides of a cube or skybox texture from separate PNG files, but only if the <span>file</span> attribute is omitted and the <span>builtin</span> attribute is set to "none". If any one of these attributes are omitted, the corresponding side is filled with the color specified by the <span>rgb1</span> attribute. The coordinate frame here is unusual. When a skybox is viewed with the default free camera in its initial configuration, the Right, Left, Up, Down sides appear where one would expect them. The Back side appears in front of the viewer, because the viewer is in the middle of the box and is facing its back. There is however a complication. In MuJoCo the +Z axis points up, while existing skybox textures (which are non-trivial to design) tend to assume that the +Y axis points up. Changing coordinates cannot be done by merely renaming files; instead one would have to transpose and/or mirror some of the images. To avoid this complication, we render the skybox rotated by 90 deg around the +X axis, in violation of our convention. However we cannot do the same for regular objects. Thus the mapping of skybox and cube textures on regular objects, expressed in the local frame of the object, is as follows:
        <br>
        Right = +X, Left = -X, Up = +Y, Down = -Y, Front = +Z, Back = -Z.
    </dd>

    <dt><b>builtin :</b> [none, gradient, checker, flat], "none"</dt>
    <dd>
        This and the remaining attributes control the generation of procedural textures. If the value of this attribute is different from "none", the texture is treated as procedural and any file names are ignored. The keywords have the following meaning:
        <br><br>

        The <b>gradient</b> type generates a color gradient from <span>rgb1</span> to <span>rgb2</span>. The interpolation in color space is done through a sigmoid function. For cube and skybox textures the gradient is along the +Y axis, i.e. from top to bottom for skybox rendering.
        <br><br>

        The <b>checker</b> type generates a 2-by-2 checker pattern with alternating colors given by <span>rgb1</span> to <span>rgb2</span>. This is suitable for rendering ground planes and also for marking objects with rotational symmetries. Note that 2d textures can be scaled so as to repeat the pattern as many times as necessary. For cube and skybox textures, the checker pattern is painted on each side of the cube.
        <br><br>

        The <b>flat</b> type fills the entire texture with <span>rgb1</span>, except for the bottom face of cube and skybox textures which is filled with <span>rgb2</span>.
    </dd>

    <dt><b>rgb1 :</b> real(3), "0.8 0.8 0.8"</dt>
    <dd>
        The first color used for procedural texture generation. This color is also used to fill missing sides of cube and skybox textures loaded from files. The components of this and all other RGB(A) vectors should be in the range [0 1].
    </dd>

    <dt><b>rgb2 :</b> real(3), "0.5 0.5 0.5" </dt>
    <dd>
        The second color used for procedural texture generation.
    </dd>

    <dt><b>mark :</b> [none, edge, cross, random], "none"</dt>
    <dd>
        Procedural textures can be marked with the <span>markrgb</span> color, on top of the colors determined by the builtin type. "edge" means that the edges of all texture images are marked. "cross" means that a cross is marked in the middle of each image. "random" means that randomly chosen pixels are marked. All markings are one-pixel wide, thus the markings appear larger and more diffuse on smaller textures.
    </dd>

    <dt><b>markrgb :</b> real(3), "0 0 0"</dt>
    <dd>
        The color used for procedural texture markings.
    </dd>

    <dt><b>random :</b> real, "0.01"</dt>
    <dd>
        When the <span>mark</span> attribute is set to "random", this attribute determines the probability of turning on each pixel. Note that larger textures have more pixels, and the probability here is applied independently to each pixel - thus the texture size and probability need to be adjusted jointly. Together with a gradient skybox texture, this can create the appearance of a night sky with stars.
    </dd>

    <dt><b>width :</b> int, "0"</dt>
    <dd>
        The width of the procedural texture, i.e. the number of columns in the image. For cube and skybox procedural textures the width and height must be equal. Larger values usually result in higher quality images, although in some cases (e.g. checker patterns) small values are sufficient.
    </dd>

    <dt><b>height :</b> int, "0"</dt>   
    <dd>
        The height of the procedural texture, i.e. the number of rows in the image.
    </dd>
</dl>


<h3 id="hfield">asset/ <b>hfield</b> (*)</h3>
<p>
    This element creates a height field asset, which can then be referenced from geoms with type "hfield". A height field, also known as terrain map, is a 2D matrix of elevation data. The data can be specified in one of three ways:
</p>

<ol>
    <li>
        The elevation data can be loaded from a PNG file. The image is converted internally to gray scale, and the intensity of each pixel is used to define elevation; white is high and black is low.
    </li>
    <br>

    <li>
        The elevation data can be loaded from a binary file in the custom format described below. As with all other matrices used in MuJoCo, the data ordering is row-major, like pixels in an image. If the data size is nrow-by-ncol, the file must have 4*(2+nrow*ncol) bytes:
        <pre>        (int32)   nrow
        (int32)   ncol
        (float32) data[nrow*ncol]
        </pre>
    </li>

    <li>
        The elevation data can be left undefined at compile time. This is done by specifying the attributes <span>nrow</span> and <span>ncol</span>. The compiler allocates space for the height field data in mjModel and sets it to 0. The user can then generate a custom height field at runtime, either programmatically or using sensor data.
    </li>
</ol>

<p>
    Regardless of which method is used to specify the elevation data, the compiler always normalizes it to the range [0 1]. However if the data is left undefined at compile time and generated later at runtime, it is the user's responsibility to normalize it.
    <br><br>

    The position and orientation of the height field is determined by the geom that references it. The spatial extent on the other hand is specified by the height field asset itself via the <span>size</span> attribute, and cannot be modified by the referencing geom (the geom size parameters are ignored in this case). The same approach is used for meshes below: positioning is done by the geom while sizing is done by the asset. This is because height fields and meshes involve sizing operations that are not common to other geoms.
    <br><br>

    For collision detection, a height field is treated as a union of triangular prisms. Collisions between height fields and other geoms (except for planes and other height fields which are not supported) are computed by first selecting the sub-grid of prisms that could collide with the geom based on its bounding box, and then using the general convex collider. The number of possible contacts between a height field and a geom is limited to 9; any contacts beyond that are discarded. To avoid penetration due to discarded contacts, the spatial features of the height field should be large compared to the geoms it collides with.
</p>

<dl>
    <dt><b>name :</b> string, optional</dt>
    <dd>
        Name of the height field, used for referencing. If the name is omitted and a file name is specified, the height field name equals the file name without the path and extension.
    </dd>

    <dt><b>file :</b> string, optional</dt>
    <dd>
        If this attribute is specified, the elevation data is loaded from the given file. If the file extension is ".png", not case-sensitive, the file is treated as a PNG file. Otherwise it is treated as a binary file in the above custom format. The number of rows and columns in the data are determined from the file contents. Loading data from a file and setting <span>nrow</span> or <span>ncol</span> below to non-zero values results is compile error, even if these settings are consistent with the file contents.
    </dd>

    <dt><b>nrow :</b> int, "0"</dt>
    <dd>
        This attribute and the next are used to allocate a height field in mjModel and leave the elevation data undefined (i.e. set to 0). This attribute specifies the number of rows in the elevation data matrix. The default value of 0 means that the data will be loaded from a file, which will be used to infer the size of the matrix.
    </dd>

    <dt><b>ncol :</b> int, "0"</dt>
    <dd>
        This attribute specifies the number of columns in the elevation data matrix.
    </dd>
    
    <dt><b>size :</b> real(4), required</dt>
    <dd>
        The four numbers here are (radius_x, radius_y, elevation_z, base_z). The height field is centered at the referencing geom's local frame. Elevation is in the +Z direction. The first two numbers specify the X and Y extent (or "radius") of the rectangle over which the height field is defined. This may seem unnatural for rectangles, but it is natural for spheres and other geom types, and we prefer to use the same convention throughout the model. The third number is the maximum elevation; it scales the elevation data which is normalized to [0-1]. Thus the minimum elevation point is at Z=0 and the maximum elevation point is at Z=elevation_z. The last number is the depth of a box in the -Z direction serving as a "base" for the height field. Without this automatically generated box, the height field would have zero thickness at places there the normalized elevation data is zero. Unlike planes which impose global unilateral constraints, height fields are treated as unions of regular geoms, so there is no notion of being "under" the height field. Instead a geom is either inside or outside the height field - which is why the inside part must have non-zero thickness. The example below is the MATLAB "peaks" surface saved in our custom height field format, and loaded as an asset with <span>size</span> = "1 1 1 0.1". The horizontal size of the box is 2, the difference between the maximum and minimum elevation is 1, and the depth of the base added below the minimum elevation point is 0.1.
        <br>
        <img src="./modeling_files/peaks.png" width="350">
    </dd>
</dl>


<h3 id="mesh">asset/ <b>mesh</b> (*)</h3>
<p>
    This element creates a mesh asset, which can then be referenced from geoms. If the referencing geom type is "mesh" the mesh is instantiated in the model, otherwise a geometric primitive is automatically fitted to it; see <a href="http://mujoco.org/book/modeling.html#geom">geom</a> element below.
    <br><br>

    MuJoCo works with triangulated meshes loaded from binary STL files. Software such as MeshLab can be used to convert from other mesh formats to STL. While any collection of triangles can be loaded as a mesh and rendered, collision detection works with the convex hull of the mesh as explained in <a href="http://mujoco.org/book/computation.html#Collision">Collision detection</a> in the Computation chapter. See also the <span>convexhull</span> attribute of the <a href="http://mujoco.org/book/modeling.html#compiler">compiler</a> element which controls the automatic generation of convex hulls. Since the STL format does not support color, the mesh appearance is controlled by the referencing geom, similarly to height fields. We are considering support for richer file formats which also specify color, but this functionality is not yet available.
    <br><br>

    Poorly designed meshes can display rendering artifacts. In particular, the shadow mapping mechanism relies on having some distance between front and back-facing triangle faces. If the faces are repeated, with opposite normals as determined by the vertex order in each triangle, this causes shadow aliasing. The solution is to remove the repeated faces (which can be done in MeshLab) or use a better designed mesh.
    <br><br>

    The size of the mesh is determined by the 3D coordinates of the vertex data in the mesh file, multiplied by the components of the <span>scale</span> attribute below. Scaling is applied separately for each coordinate axis. Note that negative scaling values can be used to flip the mesh; this is a legitimate operation. The size parameters of the referening geoms are ignored, similarly to height fields.
    <br><br>

    Positioning and orienting is complicated by the fact that vertex data are often designed relative to coordinate frames whose origin is not inside the mesh. In contrast, MuJoCo expects the origin of a geom's local frame to coincide with the geometric center of the shape. We resolve this discrepancy by pre-processing the mesh in the compiler, so that it is centered around (0,0,0) and its principal axes of inertia are the coordinate axes. We also save the translation and rotation offsets needed to achieve such alignment. These offsets are then applied to the referencing geom's position and orientation; see also <span>mesh</span> attribute of <a href="http://mujoco.org/book/modeling.html#geom">geom</a> below. Fortunately most meshes used in robot models are designed in a coordinate frame centered at the joint. This makes the corresponding MJCF model intuitive: we set the body frame at the joint, so that the joint position is (0,0,0) in the body frame, and simply reference the mesh. Below is an MJCF model fragment of a forearm, containing all the information needed to put the mesh where one would expect it to be. The body position is specified relative to the parent body, namely the upper arm (not shown). It is offset by 35 cm which is the typical length of the human upper arm. If the mesh vertex data were not designed in the above convention, we would have to use the geom position and orientation to compensate, but in practice this is rarely needed.
</p>

<pre class="prettyprint prettyprinted" style=""><span class="tag">&lt;asset&gt;</span><span class="pln">
    </span><span class="tag">&lt;mesh</span><span class="pln"> </span><span class="atn">file</span><span class="pun">=</span><span class="atv">"forearm.stl"</span><span class="tag">/&gt;</span><span class="pln">
</span><span class="tag">&lt;/asset&gt;</span><span class="pln">

</span><span class="tag">&lt;body</span><span class="pln"> </span><span class="atn">pos</span><span class="pun">=</span><span class="atv">"0 0 0.35"</span><span class="tag">/&gt;</span><span class="pln">
    </span><span class="tag">&lt;joint</span><span class="pln"> </span><span class="atn">type</span><span class="pun">=</span><span class="atv">"hinge"</span><span class="pln"> </span><span class="atn">axis</span><span class="pun">=</span><span class="atv">"1 0 0"</span><span class="tag">/&gt;</span><span class="pln">
    </span><span class="tag">&lt;geom</span><span class="pln"> </span><span class="atn">type</span><span class="pun">=</span><span class="atv">"mesh"</span><span class="pln"> </span><span class="atn">mesh</span><span class="pun">=</span><span class="atv">"forearm"</span><span class="tag">/&gt;</span><span class="pln">
</span><span class="tag">&lt;/body&gt;</span></pre>

<p>
    The inertial computation mentioned above is part of an algorithm used not only to center and align the mesh, but also to infer the mass and inertia of the body to which it is attached. This is done by computing the centroid of the triangle faces, connecting each face with the centroid to form a triangular pyramid, computing the mass and inertia of all pyramids and accumulating them. This algorithm comes from Astronomy where it is used to estimate inertial properties of asteroids. It is exact for convex meshes but is not always exact for non-convex meshes; indeed no algorithm can be exact when the notion of interior is ill-defined. Thus for non-convex models designed in CAD software (which usually knows what the interior is) it is better to ask that software to compute the inertial properties of the body and enter them in the MJCF file explicitly via the <a href="http://mujoco.org/book/modeling.html#inertial">inertial</a> element.
    <br><br>

    The full list of processing steps applied by the compiler to each mesh is as follows:
</p>

<ol>
    <li>
        Remove any repeated vertices, and re-index the faces if needed;
    </li>
    <li>
        Scale the vertex data;
    </li>
    <li>
        Generate vertex normals for rendering, using a weighted average of the surrounding face normals. If sharp edges are encountered, the renderer uses the face normals to preserve the visual information about the edge;
    </li>
    <li>
        Construct the convex hull if specified;
    </li>
    <li>
        Find the centroid of all triangle faces, and construct the union-of-pyramids representation. Triangles whose area is too small (below the <a href="http://mujoco.org/book/reference.html#glNumeric">mjMINVAL</a> value of 1E-14) result in compile error;
    </li>
    <li>
        Compute the center of mass and inertia matrix of the union-of-pyramids. Use eigenvalue decomposition to find the principal axes of inertia. Center and align the mesh, saving the translational and rotational offsets for subsequent geom-related computations.
    </li>
</ol>


<dl>
    <dt><b>name :</b> string, optional</dt>
    <dd>
        Name of the mesh, used for referencing. If omitted, the mesh name equals the file name without the path and extension.
    </dd>

    <dt><b>class :</b> string, optional</dt>
    <dd>
        Defaults class for setting unspecified attributes (only <span>scale</span> in this case).
    </dd>

    <dt><b>file :</b> string, required</dt>
    <dd>
        The STL file from which the mesh will be loaded. The path is determined as described in the <span>meshdir</span> attribute of <a href="http://mujoco.org/book/modeling.html#compiler">compiler</a>.
    </dd>

    <dt><b>scale :</b> real(3), "1 1 1"</dt>
    <dd>
        This attribute specifies the scaling that will be applied to the vertex data along each coordinate axis. Negative values are allowed, resulting in flipping the mesh along the corresponding axis.
    </dd>
</dl>


<h3 id="material">asset/ <b>material</b> (*)</h3>
<p>
    This element creates a material asset. It can be referenced from <a href="http://mujoco.org/book/modeling.html#geom">geoms</a>, <a href="http://mujoco.org/book/modeling.html#site">sites</a> and <a href="http://mujoco.org/book/modeling.html#tendon">tendons</a> to set their appearance. Note that all these elements also have a local <span>rgba</span> attribute, which is more convenient when only colors need to be adjusted, because it does not require creating materials and referencing them. Materials are useful for adjusting appearance properties beyond color. However once a material is created, it is more natural the specify the color using the material, so that all appearance properties are grouped together.
</p>

<dl>
    <dt><b>name :</b> string, required</dt>
    <dd>
        Name of the material, used for referencing.
    </dd>

    <dt><b>class :</b> string, optional</dt>
    <dd>
        Defaults class for setting unspecified attributes.
    </dd>

    <dt><b>texture :</b> string, optional</dt>
    <dd>
        If this attribute is specified, the material has a texture associated with it. Referencing the material from a model element will cause the texture to be applied to that element. Note that the value of this attribute is the name of a texture asset, not a texture file name. Textures cannot be loaded in the material definition; instead they must be loaded explicitly via the <a href="http://mujoco.org/book/modeling.html#texture">texture</a> element and then referenced here.
    </dd>

    <dt><b>texrepeat :</b> real(2), "1 1"</dt>
    <dd>
        This attribute applies to textures of type "2d". It specifies how many times the texture image is repeated, relative to either the object size or the spatial unit, as determined by the next attribute. 
    </dd>

    <dt><b>texuniform :</b> [false, true], "false"</dt>
    <dd>
        For cube textures, this attribute controls how cube mapping is applied. The default value "false" means apply cube mapping directly, using the actual size of the object. The value "true" maps the texture to a unit object before scaling it to its actual size (geometric primitives are created by the renderer as unit objects and then scaled). In some cases this leads to more uniform texture appearance, but in general, which settings produces better results depends on the texture and the object. For 2d textures, this attribute interacts with <span>texrepeat</span> above. Let texrepeat be N. The default value "false" means that the 2d texture is repeated N times over the (z-facing side of the) object. The value "true" means that the 2d texture is repeated N times over one spatial unit, regardless of object size.
    </dd>

    <dt><b>emission :</b> real, "0"</dt>
    <dd>
        Emission in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL emission vector are the RGB components of the material color multiplied by the value specified here. The alpha component is 1.
    </dd>

    <dt><b>specular :</b> real, "0.5"</dt>
    <dd>
        Specularity in OpenGL has the RGBA format, however we only provide a scalar setting. The RGB components of the OpenGL specularity vector are all equal to the value specified here. The alpha component is 1. This value should be in the range [0 1].
    </dd>

    <dt><b>shininess :</b> real, "0.5"</dt>
    <dd>
        Shininess in OpenGL is a number between 0 and 128. The value given here is multiplied by 128 before passing it to OpenGL, so it should be in the range [0 1]. Larger values correspond to tighter specular highlight (thus reducing the overall amount of highlight but making it more salient visually). This interacts with the specularity setting; see OpenGL documentation for details.
    </dd>

    <dt><b>reflectance :</b> real, "0"</dt>
    <dd>
        This attribute should be in the range [0 1]. If the value is greater than 0, and the material is applied to a plane or a box geom, the renderer will simulate reflectance. The larger the value, the stronger the reflectance. For boxes, only the face in the direction of the local +Z axis is reflective. Simulating reflectance properly requires ray-tracing which cannot (yet) be done in real-time. We are using the stencil buffer and suitable projections instead. Only the first reflective geom in the model is rendered as such. This adds one extra rendering pass through all geoms, in addition to the extra rendering pass added by each shadow-casting light.
    </dd>

    <dt><b>rgba :</b> real(4), "1 1 1 1"</dt>
    <dd>
        Color and transparency of the material. All components should be in the range [0 1]. Note that textures are applied in GL_MODULATE mode, meaning that the texture color and the color specified here are multiplied component-wise. Thus the default value of "1 1 1 1" has the effect of leaving the texture unchanged. When the material is applied to a model element which defines its own local <span>rgba</span> attribute, the local definition has precedence. Note that this "local" definition could in fact come from a defaults class. The remaining material properties always apply.
    </dd>    
</dl>
<p></p>


<h3 id="body"><b>(world)body</b> (R)</h3>
<p>
    This element is used to construct the <a href="http://mujoco.org/book/modeling.html#CTree">kinematic tree</a> via nesting. The element <span class="el">worldbody</span> is used for the top-level body, while the element <span class="el">body</span> is used for all other bodies. The top-level body is a restricted type of body: it cannot have child elements <a href="http://mujoco.org/book/modeling.html#inertial">inertial</a> and <a href="http://mujoco.org/book/modeling.html#joint">joint</a>, and also cannot have any attributes. It corresponds to the origin of the world frame, within which the rest of the kinematic tree is defined. Its body name is automatically defined as "world".

    </p><dl>
    <dt><b>name :</b> string, optional</dt>
    <dd>
        Name of the body.
    </dd>

    <dt><b>childclass :</b> string, optional</dt>
    <dd>
        If this attribute is present, all descendant elements that admit a defaults class will use the class specified here, unless they specify their own class or another body with a <span>childclass</span> attribute is encountered along the chain of nested bodies. Recall <a href="http://mujoco.org/book/modeling.html#CDefault">Default settings</a>.
    </dd>

    <dt><b>mocap :</b> [false, true], "false"</dt>
    <dd>
        If this attribute is "true", the body is labeled as a mocap body. This is allowed only for bodies that are children of the world body and have no joints. Such bodies are fixed from the viewpoint of the dynamics, but nevertheless the forward kinematics set their position and orientation from the fields mjData.mocap_pos and mjData.mocap_quat at each time step. The size of these arrays is adjusted by the compiler so as to match the number of mocap bodies in the model. This mechanism can be used to stream motion capture data into the simulation; an example application in the built-in motion capture functionality of MuJoCo HAPTIX. Mocap bodies can also be moved via mouse perturbations in the interactive visualizer, even in dynamic simulation mode. This can be useful for creating props with adjustable position and orientation. See also the <span>mocap</span> attribute of <a href="http://mujoco.org/book/modeling.html#option-flag">flag</a>.
    </dd>

    <dt><b>pos :</b> real(3), optional</dt>
    <dd>
        The 3D position of the body frame, in local or global coordinates as determined by the <span>coordinate</span> attribute of <a href="http://mujoco.org/book/modeling.html#compiler">compiler</a>. Recall the earlier discussion of local and global coordinates in <a href="http://mujoco.org/book/modeling.html#CFrame">Coordinate frames</a>. In local coordinates, if the body position is left undefined it defaults to (0,0,0). In global coordinates, an undefined body position is inferred by the compiler through the following steps:

        <ol>
            <li>
                If the inertial frame is not defined via the <a href="http://mujoco.org/book/modeling.html#inertial">inertial</a> element, it is inferred from the geoms attached to the body. If there are no geoms, the inertial frame remains undefined. This step is applied in both local and global coordinates.
            </li>
            <li>
                If both the body frame and the inertial frame are undefined, a compile error is generated. 
            </li>
            <li>
                If one of these two frames is defined and the other is not, the defined one is copied into the undefined one. At this point both frames are defined, in global coordinates.
            </li>
            <li>
                The inertial frame as well as all elements defined in the body are converted to local coordinates, relative to the body frame.
            </li>
        </ol>

        Note that whether a frame is defined or not depends on its <span>pos</span> attribute, which is in the special undefined state by default. Orientation cannot be used to make this determination because it has an internal default (the unit quaternion).
    </dd>

    <dt><b>quat, axisangle, xyaxes, zaxis, euler</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#COrientation">Frame orientations</a>. Similar to position, the orientation specified here is interpreted in either local or global coordinates as determined by the <span>coordinate</span> attribute of <a href="http://mujoco.org/book/modeling.html#compiler">compiler</a>. Unlike position which is required in local coordinates, the orientation defaults to the unit quaternion, thus specifying it is optional even in local coordinates. If the body frame was copied from the body inertial frame per the above rules, the copy operation applies to both position and orientation, and the setting of the orientation-related attributes is ignored.
    </dd>

    <dt><b>user :</b> real(nbody_user), "0 0 ..."</dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CUser">User parameters</a>.
    </dd>
    </dl>
<p></p>


<h3 id="inertial">body/ <b>inertial</b> (?)</h3>
<p>
    This element specifies the mass and inertial properties of the body. If this element is not included in a given body, the inertial properties are inferred from the geoms attached to the body. When a compiled MJCF model is saved, the XML writer saves the inertial properties explicitly using this element, even if they were inferred from geoms. The inertial frame is such that its center coincides with the center of mass of the body, and its axes coincide with the principal axes of inertia of the body. Thus the inertia matrix is diagonal in this frame.
</p>

<dl>
    <dt><b>pos :</b> real(3), required</dt>
    <dd>
        Position of the inertial frame. This attribute is required even when the inertial properties can be inferred from geoms. This is because the presence of the <span class="el">inertial</span> element itself disabled the automatic inference mechanism.
    </dd>

    <dt><b>quat, axisangle, xyaxes, zaxis, euler</b></dt>
    <dd>
        Orientation of the inertial frame. See <a href="http://mujoco.org/book/modeling.html#COrientation">Frame orientations</a>.
    </dd>   

    <dt><b>mass :</b> real, required</dt>
    <dd>
        Mass of the body. Negative values are not allowed. MuJoCo requires the inertia matrix in generalized coordinates to be positive-definite, which can sometimes be achieved even if some bodies have zero mass. In general however there is no reason to use massless bodies. Such bodies are often used in other engines to bypass the limitation that joints cannot be combined, or to attach sensors and cameras. In MuJoCo primitive joint types can be combined, and we have sites which are a more efficient attachment mechanism.
    </dd>

    <dt><b>diaginertia :</b> real(3), optional</dt>
    <dd>
        Diagonal inertia matrix, expressing the body inertia relative to the inertial frame. If this attribute is omitted, the next attribute becomes required.
    </dd>

    <dt><b>fullinertia :</b> real(6), optional</dt>
    <dd>
        Full inertia matrix M. Since M is 3-by-3 and symmetric, it is specified using only 6 numbers in the following order: M(1,1), M(2,2), M(3,3), M(1,2), M(1,3), M(2,3). The compiler computes the eigenvalue decomposition of M and sets the frame orientation and diagonal inertia accordingly. If non-positive eigenvalues are encountered (i.e. if M is not positive definite) a compile error is generated.
    </dd>
</dl>


<h3 id="joint">body/ <b>joint</b> (*)</h3>
<p>
    This element creates a joint. As explained in <a href="http://mujoco.org/book/modeling.html#CTree">Kinematic tree</a>, a joint creates motion degrees of freedom between the body where it is defined and the body's parent. If multiple joints are defined in the same body, the corresponding spatial transformations (of the body frame relative to the parent frame) are applied in order. If no joints are defined, the body is welded to its parent. Joints cannot be defined in the world body. At runtime the positions and orientations of all joints defined in the model are stored in the vector mjData.qpos, in the order in which the appear in the kinematic tree. The linear and angular velocities are stored in the vector mjData.qvel. These two vectors have different dimensionality when free or ball joints are used, because such joints represent rotations as unit quaternions.
</p>

<dl>
    <dt><b>name :</b> string, optional</dt> 
    <dd>
        Name of the joint.
    </dd>

    <dt><b>class :</b> string, optional</dt>
    <dd>
        Defaults class for setting unspecified attributes.
    </dd>

    <dt><b>type :</b> [free, ball, slide, hinge], "hinge"</dt>
    <dd>
        Type of the joint. The keywords have the following meaning:
        <br><br>

        The <b>free</b> type creates a free "joint" with three translational and three rotational degrees of freedom. In other words it makes the body floating. The rotation is represented as a unit quaternion. This joint type is only allowed in bodies that are children of the world body. No other joints can be defined in the body if a free joint is defined. Unlike the remaining joint types, free joints do not have a position within the body frame. Instead the joint position is assumed to coincide with the center of the body frame. Thus at runtime the position and orientation data of the free joint correspond to the global position and orientation of the body frame. Free joints cannot have limits.
        <br><br>

        The <b>ball</b> type creates a ball joint with three rotational degrees of freedom. The rotation is represented as a unit quaternion. The quaternion (1,0,0,0) corresponds to the initial configuration in which the model is defined. Any other quaternion is interpreted as a 3D rotation relative to this initial configuration. The rotation is around the point defined by the <span>pos</span> attribute below. If a body has a ball joint, it cannot have other rotational joints (ball or hinge). Combining ball joints with slide joints in the same body is allowed.
        <br><br>

        The <b>slide</b> type creates a sliding or prismatic joint with one translational degree of freedom. Such joints are defined by a position and a sliding direction. For simulation purposes only the direction is needed; the joint position is used for rendering purposes.
        <br><br>

        The <b>hinge</b> type creates a hinge joint with one rotational degree of freedom. The rotation takes place around a specified axis through a specified position. This is the most common type of joint and is therefore the default. Most models contact only hinge and free joints.
    </dd>

    <dt><b>pos :</b> real(3), "0 0 0"</dt>
    <dd>
        Position of the joint, specified in local or global coordinates as determined by the <span>coordinate</span> attribute of <a href="http://mujoco.org/book/modeling.html#compiler">compiler</a>. For free joints this attribute is ignored.
    </dd>

    <dt><b>axis :</b> real(3), "0 0 1"</dt>
    <dd>
        This attribute specifies the axis of rotation for hinge joints and the direction of translation for slide joints. It is ignored for free and ball joints. The vector specified here is automatically normalized to unit length as long as its length is greater than 10E-14; otherwise a compile error is generated.
    </dd>

    <dt><b>springdamper :</b> real(2), "0 0"</dt>
    <dd>
        When both numbers are positive, the compiler will override any stiffness and damping values specified with the attributes below, and will instead set them automatically so that the resulting mass-spring-damper for this joint has the desired time constant (first value) and damping ratio (second value). This is done by taking into account the joint inertia in the model reference configuration. Note that the format is the same as the solref parameter of the constraint solver.
    </dd>

    <dt><b>limited :</b> [false, true], "false"</dt>
    <dd>
        This attribute specifies if the joint has limits. It interacts with the <span>range</span> attribute below. Both must be set to enable joint limits. If this attribute is "false", any joint range data will be ignored.
    </dd>

    <dt><b>solreflimit, solimplimit</b></dt>
    <dd>
        Constraint solver parameters for simulating joint limits. See <a href="http://mujoco.org/book/modeling.html#CSolver">Solver parameters</a>.
    </dd>

    <dt><b>solreffriction, solimpfriction</b></dt>
    <dd>
        Constraint solver parameters for simulating dry friction. See <a href="http://mujoco.org/book/modeling.html#CSolver">Solver parameters</a>.
    </dd>

    <dt><b>stiffness :</b> real, "0"</dt>
    <dd>
        Joint stiffness. If this value is positive, a spring will be created with equilibrium position given by <span>springref</span> below. The spring force is computed along with the other passive forces.
    </dd>

    <dt><b>range :</b> real(2), "0 0"</dt>
    <dd>
        The joint limits. Limits can be imposed on all joint types except for free joints. For hinge and ball joints, the range is specified in degrees or radians depending on the <span>coordinate</span> attribute of <a href="http://mujoco.org/book/modeling.html#compiler">compiler</a>. For ball joints, the limit is imposed on the angle of rotation (relative to the the reference configuration) regardless of the axis of rotation. Only the second range parameter is used for ball joints; the first range parameter should be set to 0. See the <a href="http://mujoco.org/book/computation.html#coLimit">Limit</a> section in the Computation chapter for more information.
    </dd>

    <dt><b>margin :</b> real, "0"</dt>
    <dd>
        The distance threshold below which limits become active. Recall that the <a href="http://mujoco.org/book/computation.html#Solver">Constraint solver</a> normally generates forces as soon as a constraint becomes active, even if the margin parameter makes that happen at a distance. This attribute together with <span>solreflimit</span> and <span>solimplimit</span> can be used to model a soft joint limit.
    </dd>

    <dt><b>ref :</b> real, "0"</dt>
    <dd>
        The reference position or angle of the joint. This attribute is only used for slide and hinge joints. It defines the joint value corresponding to the initial model configuration. The amount of spatial transformation that the joint applies at runtime equals the current joint value stored in mjData.qpos minus this reference value stored in mjModel.qpos0. The meaning of these vectors was discussed in the <a href="http://mujoco.org/book/index.html#Standalone">Stand-alone</a> section in the Overview chapter.
    </dd>

    <dt><b>springref :</b> real, "0"</dt>
    <dd>
        The joint position or angle in which the joint spring (if any) achieves equilibrium. Similar to the vector mjModel.qpos0 which stores all joint reference values specified with the <span>ref</span> attribute above, all spring reference values specified with this attribute are stored in the vector mjModel.qpos_spring. The model configuration corresponding to mjModel.qpos_spring is also used to compute the spring reference lengths of all tendons, stored in mjModel.tendon_lengthspring. This is because <a href="http://mujoco.org/book/modeling.html#tendon">tendons</a> can also have springs.
    </dd>

    <dt><b>armature :</b> real, "0"</dt>
    <dd>
        Armature inertia (or rotor inertia) of all degrees of freedom created by this joint. These are constants added to the diagonal of the inertia matrix in generalized coordinates. They make the simulation more stable, and often increase physical realism. This is because when a motor is attached to the system with a transmission that amplifies the motor force by c, the inertia of the rotor (i.e. the moving part of the motor) is amplified by c*c. The same holds for gears in the early stages of planetary gear boxes. These extra inertias often dominate the inertias of the robot parts that are represented explicitly in the model, and the <span>armature</span> attribute is the way to model them.
    </dd>

    <dt><b>damping :</b> real, "0"</dt>
    <dd>
        Damping applied to all degrees of freedom created by this joint. Unlike friction loss which is computed by the constraint solver, damping is simply a force linear in velocity. It is included in the passive forces. Despite this simplicity, larger damping values can make numerical integrators unstable, which is why our Euler integrator handles damping implicitly. See <a href="http://mujoco.org/book/computation.html#geIntegration">Integration</a> in the Computation chapter.
    </dd>

    <dt><b>frictionloss :</b> real, "0"</dt>
    <dd>
        Friction loss due to dry friction. This value is the same for all degrees of freedom created by this joint. Semantically friction loss does not make sense for free joints, but the compiler allows it. To enable friction loss, set this attribute to a positive value.
    </dd>

    <dt><b>user :</b> real(njnt_user), "0 0 ..."</dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CUser">User parameters</a>.  
    </dd>
</dl>



<h3 id="freejoint">body/ <b>freejoint</b> (*)</h3>
<p>
    This element creates a free joint whose only attribute is <span>name</span>. The same effect can be achieved with the <a href="http://mujoco.org/book/modeling.html#joint">joint</a> element, however in that case default settings intended for actuated joints may also affect the free joint (depending on how the defaults classes are specified), which is usually undesirable. To avoid this complication, the freejoint element was introduced. It is merely an XML shortcut. The compiler transforms it into a regular joint in mjModel. If the XML model is saved, it will appear as a regular joint of type "free".
</p>

<dl>
    <dt><b>name :</b> string, optional</dt> 
    <dd>
        Name of the joint.
    </dd>
</dl>



<h3 id="geom">body/ <b>geom</b> (*)</h3>
<p>
    This element creates a geom, and attaches it rigidly to the body within which the geom is defined. Multiple geoms can be attached to the same body. At runtime they determine the appearance and collision properties of the body. At compile time they can also determine the inertial properties of the body, depending on the presence of the <a href="http://mujoco.org/book/modeling.html#inertial">inertial</a> element and the setting of the <span>inertiafromgeom</span> attribute of <a href="http://mujoco.org/book/modeling.html#compiler">compiler</a>. This is done by summing the masses and inertias of all geoms attached to the body with geom <span>group</span> in the range specified by the <span>inertiagrouprange</span> attribute of <a href="http://mujoco.org/book/modeling.html#compiler">compiler</a>. The geom masses and inertias are computed using the geom shape, a specified <span>density</span> or a geom <span>mass</span> which implies a density, and the assumption of uniform density.
    <br><br>

    Geoms are not strictly required for physics simulation. One can create and simulate a model that only has bodies and joints. Such a model can even be visualized, using equivalent inertia boxes to represent bodies. Only contact forces would be missing from such a simulation. We do not recommend using such models, but knowing that this is possible helps clarify the role of bodies and geoms in MuJoCo.
</p>

<dl>
    <dt><b>name :</b> string, optional</dt>
    <dd>
        Name of the geom.
    </dd>

    <dt><b>class :</b> string, optional</dt>
    <dd>
        Defaults class for setting unspecified attributes.
    </dd>

    <dt><b>type :</b> [plane, hfield, sphere, capsule, ellipsoid, cylinder, box, mesh], "sphere"</dt>
    <dd>
        Type of geometric shape. The keywords have the following meaning:
        <br><br>

        The <b>plane</b> type defines a plane which is infinite for collision detection purposes. It can only be attached to the world body. The plane passes through a point specified via the <span>pos</span> attribute. It is normal to the Z axis of the geom's local frame. The +Z direction corresponds to empty space. Thus the position and orientation defaults of (0,0,0) and (1,0,0,0) would create a ground plane at Z=0 elevation, with +Z being the vertical direction in the world (which is MuJoCo's convention). Since the plane is infinite, it could have been defined using any other point in the plane. The specified position however has additional meaning with regard to rendering. Planes are rendered as rectangles of finite size, as determined by the <span>size</span> attribute. This rectangle is centered at the specified position. Three size parameters are required. The first two specify the half-size of the rectangle along the X and Y axes. The third size parameter is unusual: it specifies the spacing between the grid subdivisions of the plane for rendering purposes. The subdivisions are revealed in wireframe rendering mode, but in general they should not be used to paint a grid over the ground plane (textures should be used for that purpose). Instead their role is to improve lighting and shadows, similar to the subdivisions used to render boxes. When planes are viewed from the back, the are automatically made semi-transparent. Planes and the +Z faces of boxes are the only surfaces that can show reflections, if the <a href="http://mujoco.org/book/modeling.html#material">material</a> applied to the geom has positive reflection.
        <br><br>

        The <b>hfield</b> type defines a height field geom. The geom must reference the desired height field asset with the <span>hfield</span> attribute below. The position and orientation of the geom set the position and orientation of the height field. The size of the geom is ignored, and the size parameters of the height field asset are used instead. See the description of the <a href="http://mujoco.org/book/modeling.html#hfield">hfield</a> element. Similar to planes, height field geoms can only be attached to the world body.
        <br><br>

        The <b>sphere</b> type defines a sphere. This and the next four types correspond to built-in geometric primitives. These primitives are treated as analytic surfaces for collision detection purposes, in many cases relying on custom pair-wise collision routines. Models including only planes, spheres, capsules and boxes are the most efficient in terms of collision detection. Other geom types invoke the general-purpose convex collider. The sphere is centered at the geom's position. Only one size parameter is used, specifying the radius of the sphere. Rendering of geometric primitives is done with automatically generated meshes whose density can be adjusted via <a href="http://mujoco.org/book/modeling.html#quality">quality</a>. The sphere mesh is triangulated along the lines of latitude and longitude, with the Z axis passing through the north and south pole. This can be useful in wireframe mode for visualizing frame orientation.
        <br><br>

        The <b>capsule</b> type defines a capsule, which is a cylinder capped with two half-spheres. It is oriented along the Z axis of the geom's frame. When the geom frame is specified in the usual way, two size parameters are required: the radius of the capsule followed by the half-height of the cylinder part. However capsules as well as cylinders can also be thought of as connectors, allowing an alternative specification with the <span>fromto</span> attribute below. In that case only one size parameter is required, namely the radius of the capsule.
        <br><br>

        The <b>ellipsoid</b> type defines a ellipsoid. This is a sphere scaled separately along the X, Y and Z axes of the local frame. It requires three size parameters, corresponding to the three radii. Note that even though ellipsoids are smooth, their collisions are handled via the general-purpose convex collider. The only exception are plane-ellipsoid collisions which are computed analytically.
        <br><br>

        The <b>cylinder</b> type defines a cylinder. It requires two size parameters: the radius and half-height of the cylinder. The cylinder is oriented along the Z axis of the geom's frame. It can alternatively be specified with the <span>fromto</span> attribute below. 
        <br><br>

        The <b>box</b> type defines a box. Three size parameters are required, corresponding to the half-sizes of the box along the X, Y and Z axes of the geom's frame. Note that box-box collisions are the only pair-wise collision type that can generate a large number of contact points, up to 8 depending on the configuration. The contact generation itself is fast but this can slow down the constraint solver. As an alternative, we provide the <span>boxconvex</span> attribute in <a href="http://mujoco.org/book/modeling.html#option-flag">flag</a> which causes the general-purpose convex collider to be used instead, yielding at most one contact point per geom pair.
        <br><br>

        The <b>mesh</b> type defines a mesh. The geom must reference the desired mesh asset with the <span>mesh</span> attribute. Note that mesh assets can also be referenced from other geom types, causing primitive shapes to be fitted; see below. The size is determined by the mesh asset and the geom size parameters are ignored. Unlike all other geoms, the position and orientation of mesh geoms after compilation do not equal the settings of the corresponding attributes here. Instead they are offset by the translation and rotation that were needed to center and align the mesh asset in its own coordinate frame. Recall the discussion of centering and alignment in the <a href="http://mujoco.org/book/modeling.html#mesh">mesh</a> element.
    </dd>

    <dt><b>contype :</b> int, "1"</dt>
    <dd>
        This attribute and the next specify 32-bit integer bitmasks used for contact filtering of dynamically generated contact pairs. See <a href="http://mujoco.org/book/computation.html#Collision">Collision detection</a> in the Computation chapter. Two geoms can collide if the <span>contype</span> of one geom is compatible with the <span>conaffinity</span> of the other geom or vice versa. Compatible means that the two bitmasks have a common bit set to 1.
    </dd>

    <dt><b>conaffinity :</b> int, "1"</dt>
    <dd>
        Bitmask for contact filtering; see <span>contype</span> above.
    </dd>

    <dt><b>condim :</b> int, "3"</dt>
    <dd>
        The dimensionality of the contact space for a dynamically generated contact pair is set to the maximum of the <span>condim</span> values of the two participating geoms. See <a href="http://mujoco.org/book/computation.html#coContact">Contact</a> in the Computation chapter. The allowed values and their meaning are:
        <br>
        <table border="1">
        <tbody><tr>
            <td class="el1">condim</td>
            <td class="el1">Description</td>
        </tr>
        <tr>
            <td>1</td>
            <td>Frictionless contact.</td>
        </tr>
        <tr>
            <td>3</td>
            <td>
                Regular frictional contact, opposing slip in the tangent plane.
            </td>
        </tr>
        <tr>
            <td>4</td>
            <td>
                Frictional contact, opposing slip in the tangent plane and rotation around the contact normal. This is useful for modeling soft contacts (independent of contact penetration).
            </td>
        </tr>
        <tr>
            <td>6</td>
            <td>
                Frictional contact, opposing slip in the tangent plane, rotation around the contact normal and rotation around the two axes of the tangent plane. The latter frictional effects are useful for preventing objects from indefinite rolling.
            </td>
        </tr>
        </tbody></table>
    </dd>

    <dt><b>group :</b> int, "0"</dt>
    <dd>
        This attribute specifies an integer group to which the geom belongs. The only effect on the physics is at compile time, when body masses and inertias are inferred from geoms selected based on their group; see <span>inertiagrouprange</span> attribute of <a href="http://mujoco.org/book/modeling.html#compiler">compiler</a>. At runtime this attribute is used by the visualizer to enable and disable the rendering of entire geom groups. It can also be used as a tag for custom computations.
    </dd>

    <dt><b>size :</b> real(3), "0 0 0"</dt>
    <dd>
        Geom size parameters. The number of required parameters and their meaning depends on the geom type as documented under the <span>type</span> attribute. Here we only provide a summary. All required size parameters must be positive; the internal defaults correspond to invalid settings. Note that when a non-mesh geom type references a mesh, a geometric primitive of that type is fitted to the mesh. In that case the sizes are obtained from the mesh, and the geom size parameters are ignored. Thus the number and description of required size parameters in the table below only apply to geoms that do not reference meshes.
        <br>
        <table border="1">
        <tbody><tr>
            <td class="el1">Type</td> 
            <td class="el1">Number</td> 
            <td class="el1">Description</td>
        </tr>
        <tr>
            <td>plane</td> 
            <td>3</td> 
            <td>X half-size; Y half-size; spacing between square grid lines for rendering.</td>
        </tr>
        <tr>
            <td>hfield</td> 
            <td>0</td> 
            <td>The geom sizes are ignored and the height field sizes are used instead.</td>
        </tr>
        <tr>
            <td>sphere</td> 
            <td>1</td> 
            <td>Radius of the sphere.</td>
        </tr>
        <tr>
            <td>capsule</td> 
            <td>1 or 2</td> 
            <td>Radius of the capsule; half-length of the cylinder part when not using the fromto specification.</td>
        </tr>
        <tr>
            <td>ellipsoid</td> 
            <td>3</td> 
            <td>X radius; Y radius; Z radius.</td>
        </tr>
            <tr><td>cylinder</td> 
            <td>1 or 2</td> 
            <td>Radius of the cylinder; half-length of the cylinder when not using the fromto specification.</td>
        </tr><tr>
            <td>box</td> 
            <td>3</td> 
            <td>X half-size; Y half-size; Z half-size.</td>
        </tr>
        <tr>
            <td>mesh</td> 
            <td>0</td> 
            <td>The geom sizes are ignored and the mesh sizes are used instead.</td>
        </tr>
        </tbody></table>
    </dd>

    <dt><b>material :</b> string, optional </dt>
    <dd>
        If specified, this attribute applies a material to the geom. The material determines the visual properties of the geom. The only exception is color: if the <span>rgba</span> attribute below is different from its internal default, it takes precedence while the remaining material properties are still applied. Note that if the same material is referenced from multiple geoms (as well as sites and tendons) and the user changes some of its properties at runtime, these changes will take effect immediately for all model elements referencing the material. This is because the compiler saves the material and its properties as a separate element in mjModel, and the elements using this material only keep a reference to it.
    </dd>

    <dt><b>rgba :</b> real(4), "0.5 0.5 0.5 1"</dt>
    <dd>
        Instead of creating material assets and referencing them, this attribute can be used to set color and transparency only. This is not as flexible as the material mechanism, but is more convenient and is often sufficient. If the value of this attribute is different from the internal default, it takes precedence over the material.
    </dd>

    <dt><b>friction :</b> real(3), "1 0.005 0.0001"</dt>
    <dd>
        Contact friction parameters for dynamically generated contact pairs. The first number is the sliding friction, acting along both axes of the tangent plane. The second number is the torsional friction, acting around the contact normal. The third number is the rolling friction, acting around both axes of the tangent plane. The friction parameters for the contact pair are computed as the element-wise maximum of the geom-specific parameters. See also <a href="http://mujoco.org/book/computation.html#soParameters">Parameters</a> section in the Computation chapter.
    </dd>

    <dt><b>mass :</b> real, optional</dt>
    <dd>
        If this attribute is specified, the <span>density</span> attribute below is ignored and the geom density is computed from the given mass, using the geom shape and the assumption of uniform density. The computed density is then used to obtain the geom inertia. Recall that the geom mass and inerta are only used during compilation, to infer the body mass and inertia if necessary. At runtime only the body inertial properties affect the simulation; the geom mass and inertia are not even saved in mjModel.
    </dd>

    <dt><b>density :</b> real, "1000"</dt>
    <dd>
        Material density used to compute the geom mass and inertia. The computation is based on the geom shape and the assumption of uniform density. The internal default of 1000 is the density of water in SI units. This attribute is used only when the <span>mass</span> attribute above is unspecified.
    </dd>

    <dt><b>solmix :</b> real, "1"</dt>
    <dd>
        This attribute specifies the weight used for averaging of constraint solver parameters. Recall that the solver parameters for a dynamically generated geom pair are obtained as a weighted average of the geom-specific parameters.
    </dd>

    <dt><b>solref, solimp</b></dt>
    <dd>
        Constraint solver parameters for contact simulation. See <a href="http://mujoco.org/book/modeling.html#CSolver">Solver parameters</a>.
    </dd>

    <dt><b>margin :</b> real, "0"</dt>
    <dd>
        Distance threshold below which contacts are detected and included in the global array mjData.contact. This however does not mean that contact force will be generated. A contact is considered active only if the distance between the two geom surfaces is below margin-gap. Recall that constraint impedance can be a function of distance, as explained in <a href="http://mujoco.org/book/modeling.html#CSolver">Solver parameters</a>. The quantity this function is applied to is the distance between the two geoms minus the margin plus the gap.
    </dd>

    <dt><b>gap :</b> real, "0"</dt>
    <dd>
        This attribute is used to enable the generation of inactive contacts, i.e. contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.
    </dd>

    <dt><b>fromto :</b> real(6), optional</dt>
    <dd>
        This attribute can only be used with capsule and cylinder geoms. It provides an alternative specification of the geom length as well as the frame position and orientation. The six numbers are the 3D coordinates of one point followed by the 3D coordinates of another point. The cylinder geom (or cylinder part of the capsule geom) connects these two points, with the +Z axis of the geom's frame oriented from the first towards the second point. The frame orientation is obtained with the same procedure as the <span>zaxis</span> attribute described in <a href="http://mujoco.org/book/modeling.html#COrientation">Frame orientations</a>. The frame position is in the middle between the two points. If this attribute is specified, the remaining position and orientation-related attributes are ignored.
    </dd>

    <dt><b>pos :</b> real(3), "0 0 0"</dt>
    <dd>
        Position of the geom frame, in local or global coordinates as determined by the <span>coordinate</span> attribute of <a href="http://mujoco.org/book/modeling.html#compiler">compiler</a>.
    </dd>

    <dt><b>quat, axisangle, xyaxes, zaxis, euler</b></dt>
    <dd>
        Orientation of the geom frame. See <a href="http://mujoco.org/book/modeling.html#COrientation">Frame orientations</a>.        
    </dd>

    <dt><b>hfield :</b> string, optional</dt>
    <dd>
        This attribute must be specified if and only if the geom type is "hfield". It references the height field asset to be instantiated at the position and orientation of the geom frame.
    </dd>

    <dt><b>mesh :</b> string, optional</dt>
    <dd>
        If the geom type is "mesh", this attribute is required. It references the mesh asset to be instantiated. This attribute can also be specified if the geom type corresponds to a geometric primitive, namely one of "sphere", "capsule", "cylinder", "ellipsoid", "box". In that case the primitive is automatically fitted to the mesh asset referenced here. The fitting procedure uses either the equivalent inertia box or the axis-aligned bounding box of the mesh, as determined by the attribute <span>fitaabb</span> of <a href="http://mujoco.org/book/modeling.html#compiler">compiler</a>. The resulting size of the fitted geom is usually what one would expect, but if not, it can be further adjusted with the <span>fitscale</span> attribute below. In the compiled mjModel the geom is represented as a regular geom of the specified primitive type, and there is no reference to the mesh used for fitting.
    </dd>

    <dt><b>fitscale :</b> real, "1"</dt>
    <dd>
        This attribute is used only when a primitive geometric type is being fitted to a mesh asset. The scale specified here is relative to the output of the automated fitting procedure. The default value of 1 leaves the result unchanged, a value of 2 makes all sizes of the fitted geom two times larger.
    </dd>

    <dt><b>user :</b> real(nuser_geom), "0 0 ..."</dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CUser">User parameters</a>.        
    </dd>
</dl>   


<h3 id="site">body/ <b>site</b> (*)</h3>
<p>
    This element creates a site, which is a simplified and restricted kind of geom. A small subset of the geom attributes are available here; see the <a href="http://mujoco.org/book/modeling.html#geom">geom</a> element for their detailed documentation. Semantically sites represent locations of interest relative to the body frames. Sites do not participate in collisions and computation of body masses and inertias. The geometric shapes that can be used to render sites are limited to a subset of the available geom types. However sites can be used in some places where geoms are not allowed: mounting sensors, specifying via-points of spatial tendons, constructing slider-crank transmissions for actuators.
</p>
 
 <dl>
    <dt><b>name :</b> string, optional</dt>
    <dd>
        Name of the site.
    </dd>

    <dt><b>class :</b> string, optional</dt>
    <dd>
        Defaults class for setting unspecified attributes.
    </dd>

    <dt><b>type :</b> [sphere, capsule, ellipsoid, cylinder, box], "sphere"</dt>
    <dd>
        Type of geometric shape. This is used for rendering, and also determines the active sensor zone for <a href="http://mujoco.org/book/modeling.html#sensor-touch">touch sensors</a>.
    </dd>

    <dt><b>group :</b> int, "0"</dt>
    <dd>
        Integer group to which the site belongs. This attribute can be used for custom tags. It is also used by the visualizer to enable and disable the rendering of entire groups of sites.
    </dd>

    <dt><b>material :</b> string, optional</dt>
    <dd>
        Material used to specify the visual properties of the site.
    </dd>

    <dt><b>rgba :</b> real(4), "0.5 0.5 0.5 1"</dt>
    <dd>
        Color and transparency. If this value is different from the internal default, it overrides the corresponding material properties.
    </dd>

    <dt><b>size :</b> real(3), "0 0 0"</dt>
    <dd>
        Sizes of the geometric shape representing the site.
    </dd>

    <dt><b>pos :</b> real(3), "0 0 0"</dt>
    <dd>
        Position of the site frame.
    </dd>

    <dt><b>quat, axisangle, xyaxes, zaxis, euler</b></dt>
    <dd>
        Orientation of the site frame. See <a href="http://mujoco.org/book/modeling.html#COrientation">Frame orientations</a>.
    </dd>

    <dt><b>user :</b> real(nuser_site), "0 0 ..." </dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CUser">User parameters</a>.    
    </dd>
</dl>   


<h3 id="camera">body/ <b>camera</b> (*)</h3>
<p>
    This element creates a camera, which moves with the body where it is defined. To create a fixed camera, define it in the world body. The cameras created here are in addition to the default free camera which is always defined and is adjusted via the <a href="http://mujoco.org/book/modeling.html#visual">visual</a> element. In HAPTIX such user-defined cameras can be enabled from the Render dialog, while in Pro they are enabled programmatically. Internally MuJoCo uses a flexible camera model, where the viewpoint and projection surface are adjusted independently so as to obtain oblique projections needed for virtual environments. This functionality however is not accessible through MJCF. Instead, the cameras created with this element (as well as the free camera) have a viewpoint that is always centered in front of the projection surface. The viewpoint coincides with the center of the camera frame. The camera is looking along the -Z axis of its frame. The +X axis points to the right, and the +Y axis points up. Thus the frame position and orientation are the key adjustments that need to be made here.
</p>

<dl>
    <dt><b>name :</b> string, optional</dt>
    <dd>
        Name of the camera.
    </dd>

    <dt><b>class :</b> string, optional</dt>
    <dd>
        Defaults class for setting unspecified attributes.      
    </dd>

    <dt><b>mode :</b> [fixed, track, trackcom, targetbody, targetbodycom], "fixed"</dt>
    <dd>
        This attribute specifies how the camera position and orientation in world coordinates are computed in forward kinematics (which in turn determine what the camera sees). "fixed" means that the position and orientation specified below are fixed relative to the parent (i.e. the body where the camera is defined). "track" means that the camera position is at a constant offset from the parent in world coordinates, while the camera orientation is constant in world coordinates. These constants are determined by applying forward kinematics in qpos0 and treating the camera as fixed. Tracking can be used for example to position a camera above a body, point it down so it sees the body, and have it always remain above the body no matter how the body translates and rotates. "trackcom" is similar to "track" but the constant spatial offset is defined relative to the center of mass of the kinematic subtree starting at the parent body. This can be used to keep an entire mechanism in view. Note that the subtree center of mass for the world body is the center of mass of the entire model. So if a camera is defined in the world body in mode "trackcom", it will track the entire model. "targetbody" means that the camera position is fixed in the parent body, while the camera orientation is adjusted so that it always points towards the targeted body (which is specified with the <span>target</span> attribute below). This can be used for example to model an eye that fixates a moving object; the object will be the target, and the camera/eye will be defined in the body corresponding to the head. "targetbodycom" is the same as "targetbody" but the camera is oriented towards the center of mass of the subtree starting at the target body.
    </dd>

    <dt><b>target :</b> string, optional</dt>
    <dd>
        When the camera <span>mode</span> is "targetbody" or "targetbodycom", this attribute becomes required. It specifies which body should be targeted by the camera. In all other modes this attribute is ignored.
    </dd>

    <dt><b>fovy :</b> real, "45"</dt>
    <dd>
        Vertical field of view of the camera, expressed in degrees regardless of the global <span>angle</span> setting. The horizontal field of view is computed automatically given the window size and the vertical field of view.
    </dd>

    <dt><b>ipd :</b> real, "0.068"</dt>
    <dd>
        Inter-pupilary distance. This attribute only has an effect during stereoscopic rendering. It specifies the distance between the left and right viewpoints. Each viewpoint is shifted by +/- half of the distance specified here, along the X axis of the camera frame.
    </dd>

    <dt><b>pos :</b> real(3), "0 0 0"</dt>
    <dd>
        Position of the camera frame.
    </dd>

    <dt><b>quat, axisangle, xyaxes, zaxis, euler</b></dt>
    <dd>
        Orientation of the camera frame. See <a href="http://mujoco.org/book/modeling.html#COrientation">Frame orientations</a>.
    </dd>

    <dt><b>user :</b> real(nuser_cam), "0 0 ..." </dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CUser">User parameters</a>.    
    </dd>
</dl>   


<h3 id="light">body/ <b>light</b> (*)</h3>
<p>
    This element creates a light, which moves with the body where it is defined. To create a fixed light, define it in the world body. The lights created here are in addition to the default headlight which is always defined and is adjusted via the <a href="http://mujoco.org/book/modeling.html#visual">visual</a> element. MuJoCo relies on the standard lighting model in OpenGL (fixed functionality) augmented with shadow mapping. The effects of lights are additive, thus adding a light always makes the scene brighter. The maximum number of lights that can be active simultaneously is 8, counting the headlight. The light is shining along the direction specified by the <span>dir</span> attribute. It does not have a full spatial frame with three orthogonal axes.
</p>

<dl>
    <dt><b>name :</b> string, optional</dt>
    <dd>
        Name of the light.
    </dd>

    <dt><b>class :</b> string, optional</dt>
    <dd>
        Defaults class for setting unspecified attributes.          
    </dd>

    <dt><b>mode :</b> [fixed, track, trackcom, targetbody, targetbodycom], "fixed"</dt>
    <dd>
        This is identical to the <span>mode</span> attribute of <a href="http://mujoco.org/book/modeling.html#camera">camera</a> above. It specifies the how the light position and orientation in world coordinates are computed in forward kinematics (which in turn determine what the light illuminates).        
    </dd>

    <dt><b>target :</b> string, optional</dt>
    <dd>
        This is identical to the <span>target</span> attribute of <a href="http://mujoco.org/book/modeling.html#camera">camera</a> above. It specifies which body should be targeted in "targetbody" and "targetbodycom" modes.  
    </dd>

    <dt><b>directional :</b> [false, true], "false"</dt>
    <dd>
        The light is directional if this attribute is "true", otherwise it is a spotlight.
    </dd>

    <dt><b>castshadow :</b> [false, true], "true"</dt>
    <dd>
        If this attribute is "true" the light will cast shadows. More precisely, the geoms illuminated by the light will cast shadows, however this is a property of lights rather than geoms. Since each shadow-casting light causes one extra rendering pass through all geoms, this attribute should be used with caution. Higher quality of the shadows is achieved by increasing the value of the <span>shadowsize</span> attribute of <a href="http://mujoco.org/book/modeling.html#quality">quality</a>, as well as positioning spotlights closer to the surface on which shadows appear, and limiting the volume in which shadows are cast. For spotlights this volume is a cone, whose angle is the <span>cutoff</span> attribute below multiplied by the <span>shadowscale</span> attribute of <a href="http://mujoco.org/book/modeling.html#map">map</a>. For directional lights this volume is a box, whose half-sizes in the directions orthogonal to the light are the model extent multiplied by the <span>shadowclip</span> attribute of <a href="http://mujoco.org/book/modeling.html#map">map</a>. The model extent is computed by the compiler but can also be overridden by specifying the <span>extent</span> attribute of <a href="http://mujoco.org/book/modeling.html#statistic">statistic</a>. Internally the shadow-mapping mechanism renders the scene from the light viewpoint (as if it were a camera) into a depth texture, and then renders again from the camera viewpoint, using the depth texture to create shadows. The internal rendering pass uses the same near and far clipping planes as regular rendering, i.e. these clipping planes bound the cone or box shadow volume in the light direction. As a result, some shadows (especially those very close to the light) may be clipped.
    </dd>

    <dt><b>active :</b> [false, true], "true"</dt>
    <dd>
        The light is active if this attribute is "true". This can be used at runtime to turn lights on and off.
    </dd>

    <dt><b>pos :</b> real(3), "0 0 0"</dt>
    <dd>
        Position of the light. This attribute only affects the rendering for spotlights, but it should also be defined for directional lights because we render the cameras as decorative elements.
    </dd>

    <dt><b>dir :</b> real(3), "0 0 -1"</dt>
    <dd>
        Direction of the light.
    </dd>

    <dt><b>attenuation :</b> real(3), "1 0 0"</dt>
    <dd>
        These are the constant, linear and quadratic attenuation coefficients in OpenGL. The default corresponds to no attenuation. See the OpenGL documentation for more information on this and all other OpenGL-related properties.
    </dd>

    <dt><b>cutoff :</b> real, "45"</dt>
    <dd>
        Cutoff angle for spotlights, always in degrees regardless of the global <span>angle</span> setting.
    </dd>

    <dt><b>exponent :</b> real, "10"</dt>
    <dd>
        Exponent for spotlights. This setting controls the softness of the spotlight cutoff.
    </dd>

    <dt><b>ambient :</b> real(3), "0 0 0"</dt>
    <dd>
        The ambient color of the light.
    </dd>

    <dt><b>diffuse :</b> real(3), "0.7 0.7 0.7"</dt>
    <dd>
        The diffuse color of the light.
    </dd>

    <dt><b>specular :</b> real(3), "0.3 0.3 0.3"</dt>
    <dd>
        The specular color of the light.
    </dd>
</dl>   


<h3 id="contact"><b>contact</b> (*)</h3>
<p>
    This is a grouping element and does not have any attributes. It groups elements that are used to adjust the generation of candidate contact pairs for collision checking. <a href="http://mujoco.org/book/computation.html#Collision">Collision detection</a> was described in detail in the Computation chapter, thus the description here is brief.
</p>

<h3 id="pair">contact/ <b>pair</b> (*)</h3>
<p>
    This element creates a predefined geom pair, which will be checked for collision if the <span>collision</span> attribute of <a href="http://mujoco.org/book/modeling.html#option">option</a> is set to "all" or "predefined". Unlike dynamically generated pairs whose properties are inferred from the corresponding geom properties, the pairs created here specify all their properties explicitly or through defaults, and the properties of the individual geoms are not used. Anisotropic friction can only be created with this element.
</p>

<dl>
    <dt><b>class :</b> string, optional </dt>
    <dd>
        Defaults class for setting unspecified attributes.                  
    </dd>

    <dt><b>geom1 :</b> string, required</dt>
    <dd>
        The name of the first geom in the pair.
    </dd>

    <dt><b>geom2 :</b> string, required</dt>
    <dd>
        The name of the second geom in the pair. The contact force vector computed by the solver and stored in mjData.efc_force points from the first towards the second geom by convention. The forces applied to the system are of course equal and opposite, so the order of geoms does not affect the physics.
    </dd>

    <dt><b>condim :</b> int, "3"</dt>
    <dd>
        The dimensionality of the contacts generated by this geom pair.
    </dd>

    <dt><b>friction :</b> real(5), "1 1 0.005 0.0001 0.0001"</dt>
    <dd>
        The friction coefficients of the contacts generated by this geom pair. Making the first two coefficients different results in anisotropic tangential friction. Making the last two coefficients different results in anisotropic rolling friction. The length of this array is not enforced by the parser, and can be smaller than 5. This is because some of the coefficients may not be used, depending on the contact dimensionality. Unspecified coefficients remain equal to their defaults.
    </dd>

    <dt><b>solref, solimp</b></dt>
    <dd>
        Constraint solver parameters for contact simulation. See <a href="http://mujoco.org/book/modeling.html#CSolver">Solver parameters</a>.
    </dd>

    <dt><b>margin :</b> real, "0"</dt>
    <dd>
        Distance threshold below which contacts are detected and included in the global array mjData.contact.
    </dd>

    <dt><b>gap :</b> real, "0"</dt>
    <dd>
        This attribute is used to enable the generation of inactive contacts, i.e. contacts that are ignored by the constraint solver but are included in mjData.contact for the purpose of custom computations. When this value is positive, geom distances between margin and margin-gap correspond to such inactive contacts.       
    </dd>
</dl>


<h3 id="exclude">contact/ <b>exclude</b> (*)</h3>
<p>
    This element is used to exclude a pair of bodies from collision checking. Unlike all other contact-related elements which refer to geoms, this element refers to bodies. Experience has shown that exclusion is more useful on the level of bodies. The collision between any geom defined in the first body and any geom defined in the second body is excluded. The exclusion rules defined here are applied only when the <span>collision</span> attribute of <a href="http://mujoco.org/book/modeling.html#option">option</a> is set to "all" or "dynamic". Setting this attribute to "predefined" disables the exclusion mechanism and the geom pairs defined with the <a href="http://mujoco.org/book/modeling.html#pair">pair</a> element above are checked for collisions.
</p>

<dl>
    <dt><b>body1 :</b> string, required</dt>
    <dd>
        The name of the first body in the pair.
    </dd>

    <dt><b>body2 :</b> string, required</dt>
    <dd>
        The name of the second body in the pair.
    </dd>
</dl>


<h3 id="equality"><b>equality</b> (*)</h3>
<p>
    This is a grouping element for equality constraints. It does not have attributes. See the <a href="http://mujoco.org/book/computation.html#coEquality">Equality</a> section of the Computation chapter for a detailed description of equality constraints. Several attributes are common to all equality constraint types, thus we document them only once, under the <a href="http://mujoco.org/book/modeling.html#equality-connect">connect</a> element.
</p>


<h3 id="equality-connect">equality/ <b>connect</b> (*)</h3>
<p>
    This element creates an equality constraint that connects two bodies at a point. The point is not necessarily within the geoms volumes of either body. This constraint can be used to define ball joints outside the kinematic tree. 
</p>

<dl>
    <dt><b>name :</b> string, optional</dt>
    <dd>
        Name of the equality constraint.
    </dd>

    <dt><b>class :</b> string, optional</dt>
    <dd>
        Defaults class for setting unspecified attributes.                          
    </dd>

    <dt><b>active :</b> [false, true], "true"</dt>
    <dd>
        If this attribute is set to "true", the constraint is active and the constraint solver will try to enforce it. The corresponding field in mjModel is mjData.eq_active. This field can be used at runtime to turn specific constraints on an off.
    </dd>

    <dt><b>solref, solimp</b></dt>
    <dd>
        Constraint solver parameters for equality constraint simulation. See <a href="http://mujoco.org/book/modeling.html#CSolver">Solver parameters</a>.
    </dd>

    <dt><b>body1 :</b> string, required</dt>
    <dd>
        Name of the first body participating in the constraint.
    </dd>

    <dt><b>body2 :</b> string, optional</dt>
    <dd>
        Name of the second body participating in the constraint. If this attribute is omitted, the second body is the world body.
    </dd>

    <dt><b>anchor :</b> real(3), required</dt>
    <dd>
        Coordinates of the 3D anchor point where the two bodies are connected. In the compiled mjModel the anchor is stored twice, relative to the local frame of each body. At runtime this yields two global points computed by forward kinematics; the constraint solver pushes these points towards each other. In the MJCF model however only one point is given. We assume that the equality constraint is exactly satisfied in the configuration in which the model is defined (this applies to all other constraint types as well). The compiler uses the single anchor specified in the MJCF model to compute the two body-relative anchor points in mjModel. If the MJCF model is in global coordinates, as determined by the <span>coordinate</span> attribute of <a href="http://mujoco.org/book/modeling.html#compiler">compiler</a>, the anchor is specified in global coordinates. Otherwise the anchor is specified relative to the local coordinate frame of the <i>first</i> body.
    </dd>
</dl>


<h3 id="equality-weld">equality/ <b>weld</b> (*)</h3>
<p>
    This element creates a weld equality constraint. It attaches two bodies to each other, removing all relative degrees of freedom between them (softly of course, like all other constraints in MuJoCo). The two bodies are not required to be close to each other. The relative body position and orientation being enforced by the constraint solver is the one in which the model was defined. Note that two bodies can also be welded together rigidly, by defining one body as a child of the other body, without any joint elements in the child body.
</p>

<dl>
    <dt><b>name, class, active, solref, solimp</b></dt>
    <dd>
        Same as in <a href="http://mujoco.org/book/modeling.html#equality-connect">connect</a> element.
    </dd>

    <dt><b>body1 :</b> string, required</dt>
    <dd>
        Name of the first body.
    </dd>

    <dt><b>body2 :</b> string, optional</dt>
    <dd>
        Name of the second body. If this attribute is omitted, the second body is the world body. Welding a body to the world and changing the corresponding component of mjModel.eq_active at runtime can be used to fix the body temporarily.
    </dd>
</dl>


<h3 id="equality-joint">equality/ <b>joint</b> (*)</h3>
<p>
    This element constrains the position or angle of one joint to be a quartic polynomial of another joint. Only scalar joint types (slide and hinge) can be used.
</p>

<dl>
    <dt><b>name, class, active, solref, solimp</b></dt>
    <dd>
        Same as in <a href="http://mujoco.org/book/modeling.html#equality-connect">connect</a> element.
    </dd>

    <dt><b>joint1 :</b> string, required</dt>
    <dd>
        Name of the first joint.
    </dd>

    <dt><b>joint2 :</b> string, optional</dt>
    <dd>
        Name of the second joint. If this attribute is omitted, the first joint is fixed to a constant.
    </dd>

    <dt><b>polycoef :</b> real(4), "0 1 0 0 0"</dt>
    <dd>
        Coefficients a0 ... a4 of the quartic polynomial. If the two joint values are y and x, and their reference positions (corresponding to the joint values in the initial model configuration) are y0 and x0, the constraint is:
        <br><br>

        y-y0 = a0 + a1*(x-x0) + a2*(x-x0)^2 + a3*(x-x0)^3 + a4*(x-x0)^4
        <br><br>

        Omitting the second joint is equivalent to setting x = x0, in which case the constraint is y = y0 + a0.
    </dd>
</dl>


<h3 id="equality-tendon">equality/ <b>tendon</b> (*)</h3>
<p>
    This element constrains the length of one tendon to be a quartic polynomial of another tendon.
</p>

<dl>
    <dt><b>name, class, active, solref, solimp</b></dt>
    <dd>
        Same as in <a href="http://mujoco.org/book/modeling.html#equality-connect">connect</a> element.
    </dd>

    <dt><b>tendon1 :</b> string, required</dt>
    <dd>
        Name of the first tendon.
    </dd>

    <dt><b>tendon2 :</b> string, optional</dt>
    <dd>
        Name of the second tendon. If this attribute is omitted, the first tendon is fixed to a constant.
    </dd>

    <dt><b>polycoef :</b> real(4), "0 1 0 0"</dt>
    <dd>
        Same as in the equality/ <a href="http://mujoco.org/book/modeling.html#equality-joint">joint</a> element above, but applied to tendon lengths instead of joint positions.
    </dd>
</dl>


<h3 id="equality-distance">equality/ <b>distance</b> (*)</h3>
<p>
    This element constrains the nearest distance between two geoms. When the <span>distance</span> attribute is set to 0 the two geom surfaces slide over each other, otherwise they slide over a virtual cushion with depth equal to the specified distance. This mechanism is implemented as a modification to the collision detector. For geom pairs handled by the general-purpose convex collider, large distance values in this constraint are handled approximately, due to the nature of the underlying collision algorithm.
</p>

<dl>
    <dt><b>name, class, active, solref, solimp</b></dt>
    <dd>
        Same as in <a href="http://mujoco.org/book/modeling.html#equality-connect">connect</a> element.
    </dd>

    <dt><b>geom1 :</b> string, required</dt>
    <dd>
        Name of the first geom.
    </dd>

    <dt><b>geom2 :</b> string, required</dt>
    <dd>
        Name of the second geom.
    </dd>

    <dt><b>distance :</b> real, "0"</dt>
    <dd>
        Desired distance between the two geom surfaces. The constraint solver enforces this distance softly.
    </dd>
</dl>


<h3 id="tendon"><b>tendon</b> (*)</h3>
<p>
    Grouping element for tendon definitions. The attributes of fixed tendons are a subset of the attributes of spatial tendons, thus we document them only once under spatial tendons. Tendons can be used to impose length limits, simulate spring, damping and dry friction forces, as well as attach actuators to them. When used in equality constraints, tendons can also represent different forms of mechanical coupling.
</p>


<h3 id="spatial">tendon/ <b>spatial</b> (*)</h3>
<p>
    This element creates a spatial tendon, which is a minimum-length path passing through specified via-points and wrapping around specified obstacle geoms. The objects along the path are defined with the sub-elements <a href="http://mujoco.org/book/modeling.html#spatial-site">site</a> and <a href="http://mujoco.org/book/modeling.html#spatial-geom">geom</a> below. One can also define <a href="http://mujoco.org/book/modeling.html#spatial-pulley">pulleys</a> which split the path in multiple branches. Each branch of the tendon path must start and end with a site, and if it has multiple obstacle geoms they must be separated by sites - so as to avoid the need for an iterative solver at the tendon level. The following example illustrates a multi-branch tendon acting as a finger extensor, with a counter-weight instead of an actuator.
    <br><br>

    <a href="http://mujoco.org/book/file/tendon.xml">tendon.xml</a>
    <br><br>

    <img src="./modeling_files/tendon.png" width="400">
</p>

<dl>
    <dt><b>name :</b> string, optional</dt>
    <dd>
        Name of the tendon.
    </dd>

    <dt><b>class :</b> string, optional</dt>
    <dd>
        Defaults class for setting unspecified attributes.                          
    </dd>

    <dt><b>limited :</b> [false, true], "false"</dt>
    <dd>
        If this attribute is "true", the length limits defined by the <span>range</span> attribute below are imposed by the constraint solver.
    </dd>

    <dt><b>range :</b> real(2), "0 0"</dt>
    <dd>
        Range of allowed tendon lengths. To enable length limits, set the <span>limited</span> attribute to "true" in addition to defining the present value.
    </dd>

    <dt><b>solreflimit, solimplimit</b></dt>
    <dd>
        Constraint solver parameters for simulating tendon limits. See <a href="http://mujoco.org/book/modeling.html#CSolver">Solver parameters</a>.
    </dd>

    <dt><b>solreffriction, solimpfriction</b></dt>
    <dd>
        Constraint solver parameters for simulating dry friction in the tendon. See <a href="http://mujoco.org/book/modeling.html#CSolver">Solver parameters</a>.
    </dd>

    <dt><b>margin :</b> real, "0"</dt>
    <dd>
        The limit constraint becomes active when the absolute value of the difference between the tendon length and either limit of the specified range falls below this margin. Similar to contacts, the margin parameter is subtracted from the difference between the range limit and the tendon length. The resulting constraint distance is always negative when the constraint is active. This quantity is used to compute constraint impedance as a function of distance, as explained in <a href="http://mujoco.org/book/modeling.html#CSolver">Solver parameters</a>.
    </dd>

    <dt><b>frictionloss :</b> real, "0" </dt>
    <dd>
        Friction loss caused by dry friction. To enable friction loss, set this attribute to a positive value.
    </dd>

    <dt><b>width :</b> real, "0"</dt>
    <dd>
        Radius of the cross-section area of the spatial tendon, used for rendering. The compiler requires this value to be positive. Parts of the tendon that wrap around geom obstacles are rendered with reduced width.
    </dd>

    <dt><b>material :</b> string, optional</dt>
    <dd>
        Material used to set the appearance of the tendon.
    </dd>

    <dt><b>rgba :</b> real(4), "0.5 0.5 0.5 1"</dt>
    <dd>
        Color and transparency of the tendon. When this value is different from the internal default, it overrides the corresponding material properties.
    </dd>

    <dt><b>stiffness :</b> real, "0"</dt>
    <dd>
        Stiffness coefficient. A positive value generates a spring force (linear in position) acting along the tendon. The equilibrium length of the spring corresponds to the tendon length when the model is in its initial configuration.
    </dd>

    <dt><b>damping :</b> real, "0"</dt>
    <dd>
        Damping coefficient. A positive value generates a damping force (linear in velocity) acting along the tendon. Unlike joint damping which is integrated implicitly by the Euler method, tendon damping is not integrated implicitly, thus joint damping should be used if possible.
    </dd>

    <dt><b>user :</b> real(nuser_tendon), "0 0 ..."</dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CUser">User parameters</a>.
    </dd>
</dl>


<h3 id="spatial-site">tendon/spatial/ <b>site</b> (*)</h3>
<p>
    This attribute specifies a site that the tendon path has to pass through. Recall that sites are rigidly attached to bodies.
</p>

<dl>
    <dt><b>site :</b> string, required</dt>
    <dd>
        The name of the site that the tendon must pass through.
    </dd>
</dl>


<h3 id="spatial-geom">tendon/spatial/ <b>geom</b> (*)</h3>
<p>
    This element specifies a geom that acts as an obstacle for the tendon path. If the minimum-length path does not touch the geom it has no effect; otherwise the path wraps around the surface of the geom. Wrapping is computed analytically, which is why we restrict the geom types allowed here to spheres and cylinders. The latter are treated as having infinite length for tendon wrapping purposes.
</p>

<dl>
    <dt><b>geom :</b> string, required</dt>
    <dd>
        The name of a geom that acts as an obstacle for the tendon path. Only sphere and cylinder geoms can be referenced here.
    </dd>

    <dt><b>sidesite :</b> string, optional</dt>
    <dd>
        To prevent the tendon path from snapping from one side of the geom to the other as the model configuration varies, the user can define a preferred "side" of the geom. At runtime, the wrap that is closer to the specified site is automatically selected. Specifying a side site is often needed in practice.
    </dd>
</dl>


<h3 id="spatial-pulley">tendon/spatial/ <b>pulley</b> (*)</h3>
<p>
    This element starts a new branch in the tendon path. The branches are not required to be connected spatially. Similar to the transmissions described in the <a href="http://mujoco.org/book/computation.html#geActuation">Actuation model</a> section of the Computation chapter, the quantity that affects the simulation is the tendon length and its gradient with respect to the joint positions. If a spatial tendon has multiple branches, the length of each branch is divided by the <span>divisor</span> attribute of the pulley element that started the branch, and added up to obtain the overall tendon length. This is why the spatial relations among branches are not relevant to the simulation. The <a href="http://mujoco.org/book/file/tendon.xml">tendon.xml</a> example above illustrated the use of pulleys.
</p>

<dl>
    <dt><b>divisor :</b> real, required</dt>
    <dd>
        The length of the tendon branch started by the pulley element is divided by the value specified here. For a physical pulley that splits a single branch into two parallel branches, the common branch would have divisor value of 1 and the two branches following the pulley would have divisor values of 2. If one of them is further split by another pulley, each new branch would have divisor value of 4 and so on. Note that in MJCF each branch starts with a pulley, thus a single physical pulley is modeled with two MJCF pulleys. If no pulley elements are included in the tendon path, the first and only branch has divisor value of 1.
    </dd>
</dl>


<h3 id="fixed">tendon/ <b>fixed</b> (*)</h3>
<p>
    This element creates an abstract tendon whose length is defined as a linear combination of joint positions. Recall that the tendon length and its gradient are the only quantities needed for simulation. Thus we could define any scalar function of joint positions, call it "tendon", and plug it in MuJoCo. Presently the only such function is a fixed linear combination. The attributes of fixed tendons are a subset of the attributes of spatial tendons and have the same meaning as above.
</p>

<dl>
    <dt><b>name, class, limited, range, margin, frictionloss, stiffness, damping, user</b></dt>
    <dd>
        Same as in the <a href="http://mujoco.org/book/modeling.html#spatial">spatial</a> element.
    </dd>

    <dt><b>solreflimit, solimplimit</b></dt>
    <dd>
        Constraint solver parameters for simulating tendon limits. See <a href="http://mujoco.org/book/modeling.html#CSolver">Solver parameters</a>.
    </dd>

    <dt><b>solreffriction, solimpfriction</b></dt>
    <dd>
        Constraint solver parameters for simulating dry friction in the tendon. See <a href="http://mujoco.org/book/modeling.html#CSolver">Solver parameters</a>.
    </dd>
</dl>


<h3 id="fixed-joint">tendon/fixed/ <b>joint</b> (*)</h3>
<p>
    This element adds a joint to the computation of the fixed tendon length. The position or angle of each included joint is multiplied by the corresponding <span>coef</span> value, and added up to obtain the tendon length.
</p>

<dl>
    <dt><b>joint :</b> string, required</dt>
    <dd>
        Name of the joint to be added to the fixed tendon. Only scalar joints (slide and hinge) can be referenced here.
    </dd>

    <dt><b>coef :</b> real, required</dt>
    <dd>
        Scalar coefficient multiplying the position or angle of the specified joint.
    </dd>
</dl>



<h3 id="actuator"><b>actuator</b> (*)</h3>
<p>
    This is a grouping element for actuator definitions. Recall the discussion of MuJoCo's <a href="http://mujoco.org/book/computation.html#geActuation">Actuation model</a> in the Computation chapter, and the <a href="http://mujoco.org/book/modeling.html#CActuator">Actuator shortcuts</a> discussed earlier in this chapter. The first 13 attributes of all actuator-related elements below are the same, so we document them only once, under the <span class="el">general</span> actuator.
</p>


<h3 id="general">actuator/ <b>general</b> (*)</h3>
<p>
    This element creates a general actuator, providing full access to all actuator components and allowing the user to specify them independently.
</p>

<dl>
    <dt><b>name :</b> string, optional</dt>
    <dd>
        Element name. See <a href="http://mujoco.org/book/modeling.html#CName">Naming elements</a>.
    </dd>

    <dt><b>class :</b> string, optional</dt>
    <dd>
        Active defaults class. See <a href="http://mujoco.org/book/modeling.html#CDefault">Default settings</a>.
    </dd>

    <dt><b>ctrllimited :</b> [false, true], "false"</dt>
    <dd>
        If true, the control input to this actuator is automatically clamped to <span>ctrlrange</span> at runtime. If false, control input clamping is disabled. Note that control input clamping can also be globally disabled with the <span>clampctrl</span> attribute of option/ <a href="http://mujoco.org/book/modeling.html#option-flag">flag</a>.
    </dd>

    <dt><b>forcelimited :</b> [false, true], "false"</dt>
    <dd>
        If true, the force output of this actuator is automatically clamped to <span>forcerange</span> at runtime. If false, force output clamping is disabled.
    </dd>

    <dt><b>ctrlrange :</b> real(2), "0 0"</dt>
    <dd>
        Range for clamping the control input. The compiler expects the first value to be smaller than the second value. 
    </dd>

    <dt><b>forcerange :</b> real(2), "0 0"</dt>
    <dd>
        Range for clamping the force output. The compiler expects the first value to be no greater than the second value.
    </dd>

    <dt><b>gear :</b> real(6), "1 0 0 0 0 0"</dt>
    <dd>
        This attribute scales the length (and consequently moment arms, velocity and force) of the actuator, for all transmission types. It is different from the gain in the force generation mechanism, because the gain only scales the force output and does not affect the length, moment arms and velocity. For actuators with scalar transmission, only the first element of this vector is used. The remaining elements are needed for <span>joint</span>, <span>jointinparent</span> and <span>site</span> transmissions where this attribute is used to specify 3D force and torque axes.
    </dd>

    <dt><b>cranklength :</b> real, "0"</dt>
    <dd>
        Used only for the slider-crank transmission type. Specifies the length of the connecting rod. The compiler expects this value to be positive when a slider-crank transmission is present.
    </dd>

    <dt><b>joint :</b> string, optional</dt>
    <dd>
        This and the next four attributes determine the type of actuator transmission. All of them are optional, and exactly one of them must be specified. If this attribute is specified, the actuator acts on the given joint. For <b>hinge</b> and <b>slide</b> joints, the actuator length equals the joint position/angle times the first element of <span>gear</span>. For <b>ball</b> joints, the first three elements of <span>gear</span> define a 3d rotation axis in the child frame around which the actuator produces torque. The actuator length is defined as the dot-product between this gear axis and the angle-axis representation of the joint quaternion position. For <b>free</b> joints, <span>gear</span> defines a 3d translation axis in the world frame followed by a 3d rotation axis in the child frame. The actuator generates force and torque relative to the specified axes. The actuator length for free joints is defined as zero (so it should not be used with position servos). 
    </dd>

    <dt><b>jointinparent :</b> string, optional</dt>
    <dd>
        Identical to <span>joint</span>, except that for ball and free joints, the 3d rotation axis given by <span>gear</span> is defined in the parent frame (which is the world frame for free joints) rather than the child frame. 
    </dd>

    <dt><b>site :</b> string, optional</dt>
    <dd>
        This actuator can applies force and torque at a site. The <span>gear</span> vector defines a 3d translation axis followed by a 3d rotation axis. Both are defined in the site's frame. This can be used to model jets and propellers. The effect is similar to actuating a free joint, and the actuator length is again defined as zero. One difference from the <span>joint</span> and <span>jointinparent</span> transmissions above is that here the actuator operates on a site rather than a joint, but this difference disappears when the site is defined at the frame origin of the free-floating body. The other difference is that for site transmissions both the translation and rotation axes are defined in local coordinates. In contrast, translation is global and rotation is local for <span>joint</span>, and both translation and rotation are global for <span>jointinparent</span>.
    </dd>

    <dt><b>tendon :</b> string, optional</dt>
    <dd>
        If specified, the actuator acts on the given tendon. The actuator length equals the tendon length times the gear ratio. Both spatial and fixed tendons can be used.
    </dd>

    <dt><b>cranksite :</b> string, optional</dt>
    <dd>
        If specified, the actuator acts on a slider-crank mechanism which is implicitly determined by the actuator (i.e. it is not a separate model element). The specified site corresponds to the pin joining the crank and the connecting rod. The actuator length equals the position of the slider-crank mechanism times the gear ratio.
    </dd>

    <dt><b>slidersite :</b> string, required for slider-crank transmission</dt>
    <dd>
        Used only for the slider-crank transmission type. The specified site is the pin joining the slider and the connecting rod. The slider moves along the z-axis of the slidersite frame. Therefore the site should be oriented as needed when it is defined in the kinematic tree; its orientation cannot be changed in the actuator definition.
    </dd>

    <dt><b>user :</b> real(nuser_actuator), "0 0 ..."</dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CUser">User parameters</a>.
    </dd>

    <dt><b>dyntype :</b> [none, integrator, filter, user], "none"</dt>
    <dd>
        Activation dynamics type for the actuator. The available dynamics types were already described in the <a href="http://mujoco.org/book/computation.html#geActuation">Actuation model</a> section. Repeating that description in somewhat different notation (corresponding to the mjModel and mjData fields involved) we have:
        <br>

        <table border="1">
        <tbody><tr> 
            <td class="el1">Keyword</td> 
            <td class="el1">Description</td> 
        </tr>
        <tr>
            <td>none</td>
            <td>No internal state</td>
        </tr>
        <tr>
            <td>integrator</td>
            <td>act_dot = ctrl</td>
            </tr>
        <tr>
            <td>filter</td>
            <td>act_dot = (ctrl - act) / dynprm[0]</td>
        </tr>
        <tr>
            <td>user</td>
            <td>act_dot = mjcb_act_dyn(...)</td>
        </tr>
        </tbody></table>
    </dd>

    <dt><b>gaintype :</b> [fixed, user], "fixed"</dt>
    <dd>
        The gain and bias together determine the output of the force generation mechanism, which is currently assumed to be affine. As already explained in <a href="http://mujoco.org/book/computation.html#geActuation">Actuation model</a>, the general formula is: scalar_force = gain_term * (act or ctrl) + bias_term.
        <br>
        The formula uses the activation state when present, and the control otherwise. The keywords have the following meaning:
        <br>

        <table border="1">
        <tbody><tr> 
            <td class="el1">Keyword</td> 
            <td class="el1">Description</td> 
        </tr>
        <tr>
            <td>fixed</td>
            <td>gain_term = gainprm[0]</td>
        </tr>
        <tr>
            <td>user</td>
            <td>gain_term = mjcb_act_gain(...)</td>
        </tr>
        </tbody></table>
    </dd>

    <dt><b>biastype :</b> [none, affine, user], "none"</dt>
    <dd>
        The keywords have the following meaning:
        <br>

        <table border="1">
        <tbody><tr> 
            <td class="el1">Keyword</td> 
            <td class="el1">Description</td> 
        </tr>
        <tr>
            <td>none</td>
            <td>bias_term = 0</td>
        </tr>
        <tr>
            <td>affine</td>
            <td>bias_term = biasprm[0] + biasprm[1]*length + biasprm[2]*velocity</td>
        </tr>
        <tr>
            <td>user</td>
            <td>bias_term = mjcb_act_bias(...)</td>
        </tr>
        </tbody></table>
    </dd>

    <dt><b>dynprm :</b> real(3), "1 0 0"</dt>
    <dd>
        Activation dynamics parameters. The built-in activation types use only the first parameter, but we provide additional parameters in case user callbacks implement a more elaborate model. The length of this array is not enforced by the parser, so the user can enter as many parameters as needed.
    </dd>

    <dt><b>gainprm :</b> real(3), "1 0 0"</dt>
    <dd>
        Gain parameters. The built-in gain types use only the first parameter, but we provide additional parameters in case user callbacks implement a more elaborate model. The length of this array is not enforced by the parser, so the user can enter as many parameters as needed.
    </dd>

    <dt><b>biasprm :</b> real(3), "0 0 0"</dt>
    <dd>
        Bias parameters. The affine bias type uses all three of them. The length of this array is not enforced by the parser, so the user can enter as many parameters as needed (when using callbacks).
    </dd>   
</dl>


<h3 id="motor">actuator/ <b>motor</b> (*)</h3>
<p>
    This and the next three elements are the <a href="http://mujoco.org/book/modeling.html#CActuator">Actuator shortcuts</a> discussed earlier. When a such shortcut is encountered, the parser creates a <span class="el">general</span> actuator and sets its <span>dynprm</span>, <span>gainprm</span> and <span>biasprm</span> attributes to the internal defaults shown above, regardless of any default settings. It then adjusts <span>dyntype</span>, <span>gaintype</span> and <span>biastype</span> depending on the shortcut, parses any custom attributes (beyond the 13 common ones), and translates them into regular attributes (i.e. attributes of the <span class="el">general</span> actuator type) as explained here.
    <br><br>

    This element creates a direct-drive actuator. The underlying <span class="el">general</span> attributes are set as follows:
    <br><br>

    <table border="1">
    <tbody><tr> 
        <td class="el1">Attribute</td> 
        <td class="el1">Setting</td> 
        <td class="el1">Attribute</td> 
        <td class="el1">Setting</td> 
    </tr>
    <tr>
        <td><span>dyntype</span></td>
        <td>none</td>
        <td><span>dynprm</span></td>
        <td>1 0 0</td>
    </tr>
    <tr>
        <td><span>gaintype</span></td>
        <td>fixed</td>
        <td><span>gainprm</span></td>
        <td>1 0 0</td>
    </tr>
    <tr>
        <td><span>biastype</span></td>
        <td>none</td>
        <td><span>biasprm</span></td>
        <td>0 0 0</td>
    </tr>
    </tbody></table>
    <br>

    This element does not have custom attributes. It only has common attributes, which are:
</p>

<dl>
    <dt><b>name, class, ctrllimited, forcelimited, ctrlrange, forcerange, gear, cranklength, joint, tendon, cranksite, slidersite, user</b></dt>
    <dd>
        Same as in actuator/ <a href="http://mujoco.org/book/modeling.html#general">general</a>.
    </dd>
</dl>


<h3 id="position">actuator/ <b>position</b> (*)</h3>
<p>
    This element creates a position servo. The underlying <span class="el">general</span> attributes are set as follows:
    <br><br>

    <table border="1">
    <tbody><tr> 
        <td class="el1">Attribute</td> 
        <td class="el1">Setting</td> 
        <td class="el1">Attribute</td> 
        <td class="el1">Setting</td> 
    </tr>
    <tr>
        <td><span>dyntype</span></td>
        <td>none</td>
        <td><span>dynprm</span></td>
        <td>1 0 0</td>
    </tr>
    <tr>
        <td><span>gaintype</span></td>
        <td>fixed</td>
        <td><span>gainprm</span></td>
        <td>kp 0 0</td>
    </tr>
    <tr>
        <td><span>biastype</span></td>
        <td>affine</td>
        <td><span>biasprm</span></td>
        <td>0 -kp 0</td>
    </tr>
    </tbody></table>
    <br>
    
    This element has one custom attribute in addition to the common attributes:
</p>

<dl>
    <dt><b>name, class, ctrllimited, forcelimited, ctrlrange, forcerange, gear, cranklength, joint, tendon, cranksite, slidersite, user</b></dt>
    <dd>
        Same as in actuator/ <a href="http://mujoco.org/book/modeling.html#general">general</a>.
    </dd>

    <dt><b>kp :</b> real, "1"</dt>
    <dd>
        Position feedback gain.
    </dd>
</dl>



<h3 id="velocity">actuator/ <b>velocity</b> (*)</h3>
<p>
    This element creates a velocity servo. Note that in order create a PD controller, one has to define two actuators: a position servo and a velocity servo. This is because MuJoCo actuators are SISO while a PD controller takes two control inputs (reference position and reference velocity). The underlying <span class="el">general</span> attributes are set as follows:
    <br><br>

    <table border="1">
    <tbody><tr> 
        <td class="el1">Attribute</td> 
        <td class="el1">Setting</td> 
        <td class="el1">Attribute</td> 
        <td class="el1">Setting</td> 
    </tr>
    <tr>
        <td><span>dyntype</span></td>
        <td>none</td>
        <td><span>dynprm</span></td>
        <td>1 0 0</td>
    </tr>
    <tr>
        <td><span>gaintype</span></td>
        <td>fixed</td>
        <td><span>gainprm</span></td>
        <td>kv 0 0</td>
    </tr>
    <tr>
        <td><span>biastype</span></td>
        <td>affine</td>
        <td><span>biasprm</span></td>
        <td>0 0 -kv</td>
    </tr>
    </tbody></table>
    <br>
    
    This element has one custom attribute in addition to the common attributes:
</p>

<dl>
    <dt><b>name, class, ctrllimited, forcelimited, ctrlrange, forcerange, gear, cranklength, joint, tendon, cranksite, slidersite, user</b></dt>
    <dd>
        Same as in actuator/ <a href="http://mujoco.org/book/modeling.html#general">general</a>.
    </dd>

    <dt><b>kv :</b> real, "1"</dt>
    <dd>
        Velocity feedback gain.
    </dd>
</dl>


<h3 id="cylinder">actuator/ <b>cylinder</b> (*)</h3>
<p>
    This element is suitable for modeling pneumatic or hydrolic cylinders. The underlying <span class="el">general</span> attributes are set as follows:
    <br><br>

    <table border="1">
    <tbody><tr> 
        <td class="el1">Attribute</td> 
        <td class="el1">Setting</td> 
        <td class="el1">Attribute</td> 
        <td class="el1">Setting</td> 
    </tr>
    <tr>
        <td><span>dyntype</span></td>
        <td>filter</td>
        <td><span>dynprm</span></td>
        <td>timeconst 0 0</td>
    </tr>
    <tr>
        <td><span>gaintype</span></td>
        <td>fixed</td>
        <td><span>gainprm</span></td>
        <td>area 0 0</td>
    </tr>
    <tr>
        <td><span>biastype</span></td>
        <td>affine</td>
        <td><span>biasprm</span></td>
        <td>bias</td>
    </tr>
    </tbody></table>
    <br>
    
    This element has four custom attributes in addition to the common attributes:
</p>

<dl>
    <dt><b>name, class, ctrllimited, forcelimited, ctrlrange, forcerange, gear, cranklength, joint, tendon, cranksite, slidersite, user</b></dt>
    <dd>
        Same as in actuator/ <a href="http://mujoco.org/book/modeling.html#general">general</a>.
    </dd>

    <dt><b>timeconst :</b> real, "1"</dt>
    <dd>
        Time constant of the activation dynamics.
    </dd>

    <dt><b>area :</b> real, "1"</dt>
    <dd>
        Area of the cylinder. This is used internally as actuator gain.
    </dd>

    <dt><b>diameter :</b> real, optional</dt>
    <dd>
        Instead of area the user can specify diameter. If both are specified, diameter has precedence.
    </dd>

    <dt><b>bias :</b> real(3), "0 0 0"</dt>
    <dd>
        Bias parameters, copied internally into <span>biasprm</span>.
    </dd>
</dl>



<h3 id="muscle">actuator/ <b>muscle</b> (*)</h3>
<p>
	To be written.
</p>



<h3 id="sensor"><b>sensor</b> (*)</h3>
<p>
    This is a grouping element for sensor definitions. It does not have attributes. The outputs of all sensors are concatenated in the field mjData.sensordata which has size mjModel.nsensordata. This data is not used in any internal computations. 
    <br><br>

    In addition to the sensors created with the elements below, the top-level function <a href="http://mujoco.org/book/reference.html#mj_step">mj_step</a> computes the quantities mjData.cacc, mjData.cfrc_int and mjData.crfc_ext corresponding to body accelerations and interaction forces. Some of these quantities are used to compute the output of certain sensors (force, acceleration etc.) but even if no such sensors are defined in the model, these quantities themselves are "features" that could be of interest to the user.
</p>


<h3 id="sensor-touch">sensor/ <b>touch</b> (*)</h3>
<p>
    This element creates a touch sensor. The active sensor zone is defined by a site which must be either a box or an ellipsoid. If a contact point falls within the site's volume, and involves a geom attached to the same body as the site, the corresponding contact force is included in the sensor reading. If a contact point falls outside the sensor zone, but the normal ray intersects the sensor zone, it is also included. This re-projection feature is needed because, without it, the contact point may leave the sensor zone from the back (due to soft contacts) and cause an erroneous force reading. The output of this sensor is non-negative scalar. It is computed by adding up the (scalar) normal forces from all included contacts. An example of touch sensor zones for a robotic hand can be found in the <a href="http://mujoco.org/book/haptix.html#mpSensors">Sensors</a> section in the MuJoCo HATPIX chapter.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>site :</b> string, required</dt>
    <dd>
        Site defining the active sensor zone.
    </dd>
</dl>


<h3 id="sensor-accelerometer">sensor/ <b>accelerometer</b> (*)</h3>
<p>
    This element creates a 3-axis accelerometer. The sensor is mounted at a site, and has the same position and orientation as the site frame. This sensor outputs three numbers, which are the linear acceleration of the site (including gravity) in local coordinates.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>site :</b> string, required</dt>
    <dd>
        Site where the sensor is mounted. The accelerometer is centered and aligned with the site local frame.
    </dd>
</dl>


<h3 id="sensor-velocimeter">sensor/ <b>velocimeter</b> (*)</h3>
<p>
    This element creates a 3-axis velocimeter. The sensor is mounted at a site, and has the same position and orientation as the site frame. This sensor outputs three numbers, which are the linear velocity of the site in local coordinates.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>site :</b> string, required</dt>
    <dd>
        Site where the sensor is mounted. The velocimeter is centered and aligned with the site local frame.
    </dd>
</dl>


<h3 id="sensor-gyro">sensor/ <b>gyro</b> (*)</h3>
<p>
    This element creates a 3-axis gyroscope. The sensor is mounted at a site, and has the same position and orientation as the site frame. This sensor outputs three numbers, which are the angular velocity of the site in local coordinates. This sensor is often used in conjunction with an <a href="http://mujoco.org/book/modeling.html#sensor-accelerometer">accelerometer</a> mounted at the same site, to simulate an inertial measurement unit (IMU).
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>site :</b> string, required</dt>
    <dd>
        Site where the sensor is mounted. The gyroscope is centered and aligned with the site local frame.
    </dd>
</dl>


<h3 id="sensor-force">sensor/ <b>force</b> (*)</h3>
<p>
    This element creates a 3-axis force sensor. The sensor outputs three numbers, which are the interaction force between a child and a parent body, expressed in the site frame defining the sensor. The convention is that the site is attached to the child body, and the force points from the child towards the parent. To change the sign of the sensor reading, use the <span>scale</span> attribute. The computation here takes into account all forces acting on the system, including contacts as well as external perturbations. Using this sensor often requires creating a dummy body welded to its parent (i.e. having no joint elements).
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>site :</b> string, required</dt>
    <dd>
        Site where the sensor is mounted. The measured interaction force is between the body where the site is defined and its parent body, and points from the child towards the parent. The physical sensor being modeled could of course be attached to the parent body, in which case the sensor data would have the opposite sign. Note that each body has a unique parent but can have multiple children, which is why we define this sensor through the child rather than the parent body in the pair.
    </dd>
</dl>


<h3 id="sensor-torque">sensor/ <b>torque</b> (*)</h3>
<p>
    This element creates a 3-axis torque sensor. This is similar to the <a href="http://mujoco.org/book/modeling.html#sensor-force">force</a> sensor above, but measures torque rather than force.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>site :</b> string, required</dt>
    <dd>
        Site where the sensor is mounted. The measured interaction torque is between the body where the site is defined and its parent body.
    </dd>
</dl>


<h3 id="sensor-magnetometer">sensor/ <b>magnetometer</b> (*)</h3>
<p>
    This element creates a magnetometer. It measures the magnetic flux at the sensor site position, expressed in the sensor site frame. The output is a 3D vector.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>site :</b> string, required</dt>
    <dd>
        The site where the sensor is attached.     
    </dd>
</dl>


<h3 id="sensor-rangefinder">sensor/ <b>rangefinder</b> (*)</h3>
<p>
    This element creates a rangefinder. It measures the distance to the nearest geom surface, along the ray defined by the positive Z-axis of the sensor site. If the ray does not intersect any geom surface, the sensor output is -1. If the origin of the ray is inside a geom, the surface is still sensed (but not the inner volume). Geoms attached to the same body as the sensor site are excluded. Invisible geoms, defined as geoms whose rgba (or whose material rgba) has alpha=0, are also excluded. Note however that geoms made invisible in the visualizer by disabling their geom group are not excluded; this is because sensor calculations are independent of the visualizer.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>site :</b> string, required</dt>
    <dd>
        The site where the sensor is attached.
    </dd>
</dl>



<h3 id="sensor-jointpos">sensor/ <b>jointpos</b> (*)</h3>
<p>
    This and the remaining sensor elements do not involve sensor-specific computations. Instead they copy into the array mjData.sensordata quantities that are already computed. This element creates a joint position or angle sensor. It can be attached to scalar joints (slide or hinge). Its output is scalar.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>joint :</b> string, required</dt>
    <dd>
        The joint whose position or angle will be sensed. Only scalar joints can be referenced here. The sensor output is copied from mjData.qpos.
    </dd>
</dl>


<h3 id="sensor-jointvel">sensor/ <b>jointvel</b> (*)</h3>
<p>
    This element creates a joint velocity sensor. It can be attached to scalar joints (slide or hinge). Its output is scalar.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>joint :</b> string, required</dt>
    <dd>
        The joint whose velocity will be sensed. Only scalar joints can be referenced here. The sensor output is copied from mjData.qvel.
    </dd>
</dl>


<h3 id="sensor-tendonpos">sensor/ <b>tendonpos</b> (*)</h3>
<p>
    This element creates a tendon length sensor. It can be attached to both spatial and fixed tendons. Its output is scalar.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>tendon :</b> string, required</dt>
    <dd>
        The tendon whose length will be sensed. The sensor output is copied from mjData.ten_length.
    </dd>
</dl>


<h3 id="sensor-tendonvel">sensor/ <b>tendonvel</b> (*)</h3>
<p>
    This element creates a tendon velocity sensor. It can be attached to both spatial and fixed tendons. Its output is scalar.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>tendon :</b> string, required</dt>
    <dd>
        The tendon whose velocity will be sensed. The sensor output is copied from mjData.ten_velocity.
    </dd>
</dl>


<h3 id="sensor-actuatorpos">sensor/ <b>actuatorpos</b> (*)</h3>
<p>
    This element creates an actuator length sensor. Recall that each actuator has a transmission which has length. This sensor can be attached to any actuator. Its output is scalar.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>actuator :</b> string, required</dt>
    <dd>
        The actuator whose transmission's length will be sensed. The sensor output is copied from mjData.actuator_length.
    </dd>
</dl>


<h3 id="sensor-actuatorvel">sensor/ <b>actuatorvel</b> (*)</h3>
<p>
    This element creates an actuator velocity sensor. This sensor can be attached to any actuator. Its output is scalar.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>actuator :</b> string, required</dt>
    <dd>
        The actuator whose transmission's velocity will be sensed. The sensor output is copied from mjData.actuator_velocity.      
    </dd>
</dl>


<h3 id="sensor-actuatorfrc">sensor/ <b>actuatorfrc</b> (*)</h3>
<p>
    This element creates an actuator force sensor. The quantity being sensed is the scalar actuator force, not the generalized force contributed by the actuator (the latter is the product of the scalar force and the vector of moment arms determined by the transmission). This sensor can be attached to any actuator. Its output is scalar.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>actuator :</b> string, required</dt>
    <dd>
        The actuator whose scalar force output will be sensed. The sensor output is copied from mjData.actuator_force.     
    </dd>
</dl>


<h3 id="sensor-ballquat">sensor/ <b>ballquat</b> (*)</h3>
<p>
    This element creates a quaternion sensor for a ball joints. It outputs 4 numbers corresponding to a unit quaternion.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>joint :</b> string, required</dt>
    <dd>
        The ball joint whose quaternion is sensed. The sensor output is copied from mjData.qpos.     
    </dd>
</dl>


<h3 id="sensor-ballangvel">sensor/ <b>ballangvel</b> (*)</h3>
<p>
    This element creates a ball joint angular velocity sensor. It outputs 3 numbers corresponding to the angular velocity of the joint. The norm of that vector is the rotation speed in rad/s and the direction is the axis around which the rotation takes place.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>joint :</b> string, required</dt>
    <dd>
        The ball joint whose angular velocity is sensed. The sensor output is copied from mjData.qvel.     
    </dd>
</dl>


<h3 id="sensor-framepos">sensor/ <b>framepos</b> (*)</h3>
<p>
    This element creates a sensor that returns the 3D position of the spatial frame of the object, in global coordinates.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>objtype :</b> [body, xbody, geom, site, camera], required</dt>
    <dd>
        The type of object to which the sensor is attached. This must be an object type that has a spatial frame. "body" refers to the inertial frame of the body, while "xbody" refers to the regular frame of the body (usually centered at the joint with the parent body).
    </dd>

    <dt><b>objname :</b> string, required</dt>
    <dd>
        The name of the object to which the sensor is attached.
    </dd>
</dl>


<h3 id="sensor-framequat">sensor/ <b>framequat</b> (*)</h3>
<p>
    This element creates a sensor that returns the unit quaternion specifying the orientation of the spatial frame of the object, in global coordinates.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>objtype :</b> [body, xbody, geom, site, camera], required</dt>
    <dd>
        The type of object to which the sensor is attached. This must be an object type that has a spatial frame. "body" refers to the inertial frame of the body, while "xbody" refers to the regular frame of the body (usually centered at the joint with the parent body).
    </dd>

    <dt><b>objname :</b> string, required</dt>
    <dd>
        The name of the object to which the sensor is attached.
    </dd>
</dl>


<h3 id="sensor-framexaxis">sensor/ <b>framexaxis</b> (*)</h3>
<p>
    This element creates a sensor that returns the 3D unit vector corresponding to the X-axis of the spatial frame of the object, in global coordinates.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>objtype :</b> [body, xbody, geom, site, camera], required</dt>
    <dd>
        The type of object to which the sensor is attached. This must be an object type that has a spatial frame. "body" refers to the inertial frame of the body, while "xbody" refers to the regular frame of the body (usually centered at the joint with the parent body).
    </dd>

    <dt><b>objname :</b> string, required</dt>
    <dd>
        The name of the object to which the sensor is attached.
    </dd>
</dl>


<h3 id="sensor-frameyaxis">sensor/ <b>frameyaxis</b> (*)</h3>
<p>
    This element creates a sensor that returns the 3D unit vector corresponding to the Y-axis of the spatial frame of the object, in global coordinates.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>objtype :</b> [body, xbody, geom, site, camera], required</dt>
    <dd>
        The type of object to which the sensor is attached. This must be an object type that has a spatial frame. "body" refers to the inertial frame of the body, while "xbody" refers to the regular frame of the body (usually centered at the joint with the parent body).
    </dd>

    <dt><b>objname :</b> string, required</dt>
    <dd>
        The name of the object to which the sensor is attached.
    </dd>
</dl>


<h3 id="sensor-framezaxis">sensor/ <b>framezaxis</b> (*)</h3>
<p>
    This element creates a sensor that returns the 3D unit vector corresponding to the Z-axis of the spatial frame of the object, in global coordinates.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>objtype :</b> [body, xbody, geom, site, camera], required</dt>
    <dd>
        The type of object to which the sensor is attached. This must be an object type that has a spatial frame. "body" refers to the inertial frame of the body, while "xbody" refers to the regular frame of the body (usually centered at the joint with the parent body).
    </dd>

    <dt><b>objname :</b> string, required</dt>
    <dd>
        The name of the object to which the sensor is attached.
    </dd>
</dl>


<h3 id="sensor-framelinvel">sensor/ <b>framelinvel</b> (*)</h3>
<p>
    This element creates a sensor that returns the 3D linear velocity of the spatial frame of the object, in global coordinates.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>objtype :</b> [body, xbody, geom, site, camera], required</dt>
    <dd>
        The type of object to which the sensor is attached. This must be an object type that has a spatial frame. "body" refers to the inertial frame of the body, while "xbody" refers to the regular frame of the body (usually centered at the joint with the parent body).
    </dd>

    <dt><b>objname :</b> string, required</dt>
    <dd>
        The name of the object to which the sensor is attached.
    </dd>
</dl>


<h3 id="sensor-frameangvel">sensor/ <b>frameangvel</b> (*)</h3>
<p>
    This element creates a sensor that returns the 3D angular velocity of the spatial frame of the object, in global coordinates.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>objtype :</b> [body, xbody, geom, site, camera], required</dt>
    <dd>
        The type of object to which the sensor is attached. This must be an object type that has a spatial frame. "body" refers to the inertial frame of the body, while "xbody" refers to the regular frame of the body (usually centered at the joint with the parent body).
    </dd>

    <dt><b>objname :</b> string, required</dt>
    <dd>
        The name of the object to which the sensor is attached.
    </dd>
</dl>


<h3 id="sensor-framelinacc">sensor/ <b>framelinacc</b> (*)</h3>
<p>
    This element creates a sensor that returns the 3D linear acceleration of the spatial frame of the object, in global coordinates.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>objtype :</b> [body, xbody, geom, site, camera], required</dt>
    <dd>
        The type of object to which the sensor is attached. This must be an object type that has a spatial frame. "body" refers to the inertial frame of the body, while "xbody" refers to the regular frame of the body (usually centered at the joint with the parent body).
    </dd>

    <dt><b>objname :</b> string, required</dt>
    <dd>
        The name of the object to which the sensor is attached.
    </dd>
</dl>


<h3 id="sensor-frameangacc">sensor/ <b>frameangacc</b> (*)</h3>
<p>
    This element creates a sensor that returns the 3D angular acceleration of the spatial frame of the object, in global coordinates.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>objtype :</b> [body, xbody, geom, site, camera], required</dt>
    <dd>
        The type of object to which the sensor is attached. This must be an object type that has a spatial frame. "body" refers to the inertial frame of the body, while "xbody" refers to the regular frame of the body (usually centered at the joint with the parent body).
    </dd>

    <dt><b>objname :</b> string, required</dt>
    <dd>
        The name of the object to which the sensor is attached.
    </dd>
</dl>



<h3 id="sensor-subtreecom">sensor/ <b>subtreecom</b> (*)</h3>
<p>
    This element creates sensor that returns the center of mass of the kinematic subtree rooted at a specified body, in global coordinates.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>body :</b> string, required</dt>
    <dd>
        Name of the body where the kinematic subtree is rooted.
    </dd>
</dl>


<h3 id="sensor-subtreelinvel">sensor/ <b>subtreelinvel</b> (*)</h3>
<p>
    This element creates sensor that returns the linear velocity of the center of mass of the kinematic subtree rooted at a specified body, in global coordinates.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>body :</b> string, required</dt>
    <dd>
        Name of the body where the kinematic subtree is rooted.
    </dd>
</dl>


<h3 id="sensor-subtreeangmom">sensor/ <b>subtreeangmom</b> (*)</h3>
<p>
    This element creates sensor that returns the angular momentum around the center of mass of the kinematic subtree rooted at a specified body, in global coordinates.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>body :</b> string, required</dt>
    <dd>
        Name of the body where the kinematic subtree is rooted.
    </dd>
</dl>


<h3 id="sensor-user">sensor/ <b>user</b> (*)</h3>
<p>
    This element creates a user sensor. MuJoCo does not know how to compute the output of this sensor. Instead the user should install the callback <a href="http://mujoco.org/book/reference.html#mjcb_sensor">mjcb_sensor</a> which is expected to fill in the sensor data in mjData.sensordata. The specification in the XML is used to allocate space for this sensor, and also determine which MuJoCo object it is attached to and what stage of computation it needs before the data can be computed. Note that the MuJoCo object referenced here can be a tuple, which in turn can reference a custom collection of MuJoCo objects - for example several bodies whose center of mass is of interest.
</p>

<dl>
    <dt><b>name, noise, cutoff, user</b></dt>
    <dd>
        See <a href="http://mujoco.org/book/modeling.html#CSensor">Sensors</a>.
    </dd>

    <dt><b>objtype :</b> [body, joint, geom, site, camera, light, mesh, hfield, texture, material, equality, tendon, actuator, sensor, numeric, text, tuple], required</dt>
    <dd>
        Type of the MuJoCo object to which the sensor is attached. This together with the objname attribute determines the actual object.
    </dd>

    <dt><b>objname :</b> string, required</dt>
    <dd>
        Name of the MuJoCo object to which the sensor is attached.
    </dd>

    <dt><b>datatype :</b> [real, positive, axis, quaternion], required</dt>
    <dd>
        The type of output generated by this sensor. "axis" means a unit-length 3D vector. "quat" means a unit quaterion. These need to be declared because when MuJoCo adds noise, it must respect the vector normalization. "real" means a generic array (or scalar) of real values to which noise can be added independently.
    </dd>

    <dt><b>needstage :</b> [pos, vel, acc], required</dt>
    <dd>
        The MuJoCo computation stage that must be completed before the user callback mjcb_sensor() is able to evaluate the output of this sensor.
    </dd>

    <dt><b>dim :</b> int, required</dt>
    <dd>
        Number of scalar outputs of this sensor.
    </dd>
</dl>



<h3 id="keyframe"><b>keyframe</b> (*)</h3>
<p>
    This is a grouping element for keyframe definitions. It does not have attributes. Keyframes can be used to create a library of states that are of interest to the user, and to initialize the simulation state to one of the states in the library. They are not needed by any MuJoCo computations. The number of keyframes allocated in mjModel is the larger of the <span>nkey</span> attribute of <a href="http://mujoco.org/book/modeling.html#size">size</a>, and the number of elements defined here. If fewer than <span>nkey</span> elements are defined here, the undefined keyframes have all their data set to 0, except for the <span>qpos</span> attribute which is set to mjModel.qpos0. The user can also set keyframe data in mjModel at runtime; this data will then appear in the saved MJCF model. Note that in HAPTIX the simulation state can be copied into a selected keyframe and vice versa; see <a href="http://mujoco.org/book/haptix.html#seSim">Sim</a> dialog in the MuJoco HAPTIX chapter. In Pro this has to be done programmatically.
</p>

<h3 id="key">keyframe/ <b>key</b> (*)</h3>
<p>
    This element sets the data for one of the keyframes. They are set in the order in which they appear here.
</p>

<dl>
    <dt><b>time :</b> real, "0"</dt>
    <dd>
        Simulation time, copied into mjData.time when the simulation state is set to this keyframe.
    </dd>

    <dt><b>qpos :</b> real(mjModel.nq), default = mjModel.qpos0</dt>
    <dd>
        Vector of joint positions, copied into mjData.qpos when the simulation state is set to this keyframe.
    </dd>

    <dt><b>qvel :</b> real(mjModel.nq), "0 0 ..."</dt>
    <dd>
        Vector of joint velocities, copied into mjData.qvel when the simulation state is set to this keyframe.
    </dd>

    <dt><b>act :</b> real(mjModel.na), "0 0 ..."</dt>
    <dd>
        Vector of actuator activations, copied into mjData.act when the simulation state is set to this keyframe.
    </dd>
</dl>


</td>
</tr>
</tbody></table>


</body></html>